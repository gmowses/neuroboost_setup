#!/bin/bash

## ===================================================================================================
##                           INSTALADOR DOCKER COMPOSE - NEUROBOOST DIGITAL
##                              TRAEFIK + PORTAINER + MINIO + FAQ SYSTEM
## ===================================================================================================
##
## VARI√ÅVEIS DE AMBIENTE SUPORTADAS (opcionais):
##   NEUROBOOST_INSTANCE     - Nome da inst√¢ncia (ex: cliente1, empresa2) [OBRIGAT√ìRIO]
##   NEUROBOOST_EMAIL        - Email para notifica√ß√µes SSL (padr√£o: ssl@neuroboost.digital)
##   NEUROBOOST_AUTO_CONFIRM - Auto-confirmar instala√ß√£o (true/false)
##
## EXEMPLO DE USO AUTOMATIZADO:
##   export NEUROBOOST_INSTANCE="cliente1"
##   export NEUROBOOST_AUTO_CONFIRM="true"
##   bash <(curl -sSL https://raw.githubusercontent.com/gmowses/neuroboost_setup/refs/heads/main/Setup)
##
## ===================================================================================================

## Vers√£o do script (SEMVER)
VERSION="2.1.9"

## Cores
AMARELO="\e[33m"
VERDE="\e[32m"
VERMELHO="\e[31m"
BRANCO="\e[97m"
RESET="\e[0m"

## Dom√≠nio base
DOMINIO_BASE="neuroboost.digital"

## Usu√°rio padr√£o
USUARIO_PADRAO="neuroboost"

## Arquivo de log
LOG_FILE="instalacao_$(date +%Y%m%d_%H%M%S).log"

## ===================================================================================================
##                                    VERIFICA√á√ïES DE SISTEMA
## ===================================================================================================

## Fun√ß√£o para verificar requisitos do sistema
verificar_requisitos_sistema() {
    local erro=0
    
    echo "üîç Verificando requisitos do sistema..."
    
    # Verifica se est√° executando como root
    if [ "$EUID" -ne 0 ]; then
        echo "‚ùå ERRO: Este script deve ser executado como usu√°rio root!"
        echo "   Execute: sudo ./Setup"
        echo "   Usu√°rio atual: $(whoami) (UID: $EUID)"
        erro=1
    else
        echo "‚úÖ Usu√°rio root confirmado (UID: $EUID)"
    fi
    
    # Verifica se √© Ubuntu
    if [ ! -f /etc/os-release ]; then
        echo "‚ùå ERRO: N√£o foi poss√≠vel identificar o sistema operacional!"
        erro=1
    else
        # L√™ informa√ß√µes do sistema
        . /etc/os-release
        
        # Verifica se √© Ubuntu
        if [ "$ID" != "ubuntu" ]; then
            echo "‚ùå ERRO: Sistema operacional n√£o suportado!"
            echo "   Sistema detectado: $PRETTY_NAME"
            echo "   Sistema requerido: Ubuntu 24.04.2 LTS"
            erro=1
        else
            echo "‚úÖ Ubuntu detectado: $PRETTY_NAME"
            
            # Verifica vers√£o espec√≠fica do Ubuntu
            if [ "$VERSION_ID" != "24.04" ]; then
                echo "‚ùå ERRO: Vers√£o do Ubuntu n√£o suportada!"
                echo "   Vers√£o detectada: $VERSION_ID ($PRETTY_NAME)"
                echo "   Vers√£o requerida: 24.04 (Ubuntu 24.04.2 LTS)"
                erro=1
            else
                echo "‚úÖ Vers√£o do Ubuntu compat√≠vel: $VERSION_ID"
                
                # Verifica se √© LTS
                if [[ "$VERSION" != *"LTS"* ]]; then
                    echo "‚ùå ERRO: Esta n√£o √© uma vers√£o LTS do Ubuntu!"
                    echo "   Vers√£o detectada: $VERSION"
                    echo "   Requerido: Ubuntu 24.04.2 LTS"
                    erro=1
                else
                    echo "‚úÖ Ubuntu LTS confirmado: $VERSION"
                    
                    # Verifica√ß√£o adicional para patch version (recomendada)
                    if command -v lsb_release >/dev/null 2>&1; then
                        local full_version=$(lsb_release -r -s)
                        echo "‚ÑπÔ∏è  Vers√£o completa detectada: $full_version"
                        if [ "$full_version" = "24.04" ]; then
                            echo "‚úÖ Ubuntu 24.04 LTS confirmado"
                        else
                            echo "‚ö†Ô∏è  Vers√£o patch diferente detectada: $full_version"
                            echo "   Recomendado: 24.04.2, mas 24.04.x deve funcionar"
                        fi
                    fi
                fi
            fi
        fi
    fi
    
    # Se houver erro, interrompe a execu√ß√£o
    if [ $erro -eq 1 ]; then
        echo ""
        echo "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó"
        echo "‚ïë                    REQUISITOS N√ÉO ATENDIDOS                   ‚ïë"
        echo "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù"
        echo ""
        echo "‚ùå Este script s√≥ pode ser executado em:"
        echo "   ‚Ä¢ Ubuntu 24.04.2 LTS"
        echo "   ‚Ä¢ Como usu√°rio root (sudo)"
        echo ""
        echo "üîß Para corrigir:"
        echo "   1. Use Ubuntu 24.04.2 LTS"
        echo "   2. Execute: sudo ./Setup"
        echo ""
        exit 1
    fi
    
    echo ""
    echo "‚úÖ Todos os requisitos de sistema atendidos!"
    echo ""
}

## ===================================================================================================
##                                         FUN√á√ïES AUXILIARES
## ===================================================================================================

## Fun√ß√£o para logging
log_message() {
    local message="$1"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    echo "[$timestamp] $message" >> "$LOG_FILE"
}

## Fun√ß√£o para exibir mensagens coloridas e logar
msg() {
    local cor=$1
    local texto=$2
    local clean_text=$(echo -e "${texto}" | sed 's/\x1b\[[0-9;]*m//g')
    
    # Exibe no terminal com cor
    echo -e "${cor}${texto}${RESET}"
    
    # Salva no log sem cor
    log_message "$clean_text"
}

## Fun√ß√£o para executar comandos e logar
exec_log() {
    local cmd="$1"
    local description="$2"
    local critical="$3"  # Se 'true', para execu√ß√£o em caso de erro
    
    log_message "EXECUTANDO: $cmd"
    if [ -n "$description" ]; then
        log_message "DESCRI√á√ÉO: $description"
    fi
    
    # Executa comando e captura sa√≠da
    local output
    local exit_code
    
    output=$(eval "$cmd" 2>&1)
    exit_code=$?
    
    # Loga a sa√≠da
    if [ -n "$output" ]; then
        log_message "SA√çDA: $output"
    fi
    log_message "C√ìDIGO DE SA√çDA: $exit_code"
    
    # Se for cr√≠tico e falhou, para a execu√ß√£o
    if [ "$critical" = "true" ] && [ $exit_code -ne 0 ]; then
        msg "$VERMELHO" "‚ùå ERRO CR√çTICO: Comando falhou: $cmd"
        msg "$VERMELHO" "‚ùå C√≥digo de sa√≠da: $exit_code"
        if [ -n "$output" ]; then
            msg "$VERMELHO" "‚ùå Sa√≠da: $output"
        fi
        log_message "ERRO CR√çTICO: Execu√ß√£o interrompida devido a falha em comando cr√≠tico"
        exit 1
    fi
    
    # Retorna o c√≥digo de sa√≠da original
    return $exit_code
}

## Fun√ß√£o para validar nome da inst√¢ncia
validar_nome_instancia() {
    local nome=$1
    # Remove caracteres especiais e converte para min√∫sculas
    nome=$(echo "$nome" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9-]//g')
    echo "$nome"
}

## Fun√ß√£o para gerar senha segura
gerar_senha() {
    local tamanho=$1
    # Gera senha com letras mai√∫sculas, min√∫sculas, n√∫meros e caracteres especiais
    senha=$(openssl rand -base64 48 | tr -d "=+/" | cut -c1-$tamanho)
    # Garante que tenha pelo menos um de cada tipo
    senha="${senha}A1@"
    # Embaralha a senha
    senha=$(echo $senha | fold -w1 | shuf | tr -d '\n' | cut -c1-$tamanho)
    echo "$senha"
}

## Fun√ß√£o para verificar se Docker est√° instalado e funcionando
verificar_docker() {
    # Verifica se o comando docker existe
    if ! command -v docker &> /dev/null; then
        log_message "Docker comando n√£o encontrado"
        return 1
    fi
    
    # Verifica se o Docker daemon est√° rodando
    if ! docker info &> /dev/null; then
        log_message "Docker daemon n√£o est√° rodando ou n√£o responde"
        return 1
    fi
    
    # Testa se consegue executar um comando b√°sico
    if ! docker ps &> /dev/null; then
        log_message "Docker ps falhou - problemas de conectividade com daemon"
        return 1
    fi
    
    log_message "Docker verificado e funcionando corretamente"
    return 0
}

## Fun√ß√£o para diagnosticar problemas do Docker
diagnosticar_docker() {
    msg "$AMARELO" "üîç Diagnosticando problemas do Docker..."
    
    echo "üìç Verificando comando docker:"
    which docker || echo "‚ùå Comando docker n√£o encontrado"
    
    echo ""
    echo "üìç Status do servi√ßo Docker:"
    systemctl status docker --no-pager -l || echo "‚ùå Erro ao verificar status"
    
    echo ""
    echo "üìç Tentando executar docker version:"
    docker version || echo "‚ùå Erro ao executar docker version"
    
    echo ""
    echo "üìç Tentando executar docker info:"
    docker info || echo "‚ùå Erro ao executar docker info"
    
    echo ""
    echo "üìç Verificando se o socket existe:"
    ls -la /var/run/docker.sock || echo "‚ùå Socket n√£o encontrado"
}





## Fun√ß√£o para aguardar container ficar healthy
aguardar_container() {
    local container=$1
    local tentativas=0
    local max_tentativas=30
    
    msg "$AMARELO" "‚è≥ Aguardando $container ficar online..."
    log_message "Aguardando container $container ficar online"
    
    while [ $tentativas -lt $max_tentativas ]; do
        if docker ps --filter "name=$container" --filter "status=running" | grep -q "$container"; then
            msg "$VERDE" "‚úÖ Container $container est√° online!"
            log_message "Container $container est√° online com sucesso"
            return 0
        fi
        sleep 5
        tentativas=$((tentativas + 1))
        
        # Mostra progresso a cada 6 tentativas (30 segundos)
        if [ $((tentativas % 6)) -eq 0 ]; then
            msg "$AMARELO" "‚è≥ Ainda aguardando $container... ($tentativas/$max_tentativas)"
            log_message "Aguardando container $container... ($tentativas/$max_tentativas)"
        fi
    done
    
    msg "$VERMELHO" "‚ùå Timeout aguardando $container"
    log_message "ERRO: Timeout aguardando container $container"
    msg "$AMARELO" "üîç Status do container:"
    
    # Captura status do container para o log
    container_status=$(docker ps -a --filter "name=$container" 2>&1)
    log_message "Status do container $container: $container_status"
    docker ps -a --filter "name=$container" || echo "‚ùå Erro ao verificar container"
    
    if docker ps -a --filter "name=$container" | grep -q "$container"; then
        msg "$AMARELO" "üìù Logs do container:"
        container_logs=$(docker logs --tail 20 "$container" 2>&1)
        log_message "Logs do container $container: $container_logs"
        docker logs --tail 20 "$container" || echo "‚ùå Erro ao obter logs"
    fi
    return 1
}

## ===================================================================================================
##                                         COLETA DE INFORMA√á√ïES
## ===================================================================================================

## ===================================================================================================
##                                    VERIFICA√á√ÉO DE REQUISITOS
## ===================================================================================================

# Verifica requisitos ANTES de inicializar qualquer coisa
verificar_requisitos_sistema

## ===================================================================================================
##                                       INICIALIZA√á√ÉO DO LOG
## ===================================================================================================

# Inicializa o arquivo de log
log_message "=========================================="
log_message "IN√çCIO DA INSTALA√á√ÉO - NEUROBOOST DIGITAL"
log_message "=========================================="
log_message "Vers√£o do script: $VERSION"
log_message "Data/Hora: $(date)"
log_message "Usu√°rio: $(whoami)"
log_message "Diret√≥rio: $(pwd)"
log_message "Sistema: $(uname -a)"
log_message "Arquivo de log: $LOG_FILE"
log_message "Requisitos de sistema verificados e aprovados"
msg "$BRANCO" "
‚ñà‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó
‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïê‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù
‚ñà‚ñà‚ïî‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïë   
‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù  ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ïö‚ïê‚ïê‚ïê‚ïê‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë   
‚ñà‚ñà‚ïë ‚ïö‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë   
‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù   ‚ïö‚ïê‚ïù   

        INSTALADOR DOCKER COMPOSE - TRAEFIK + PORTAINER + MINIO
                              VERS√ÉO: $VERSION
"

msg "$VERDE" "‚úÖ Sistema compat√≠vel: Ubuntu 24.04 LTS como root"
msg "$AMARELO" "üìù Log da instala√ß√£o: $LOG_FILE"

msg "$AMARELO" "=== CONFIGURA√á√ÉO INICIAL ==="
echo ""

## Nome da inst√¢ncia
if [ -n "$NEUROBOOST_INSTANCE" ]; then
    # Usa vari√°vel de ambiente se definida
    NOME_INSTANCIA=$(validar_nome_instancia "$NEUROBOOST_INSTANCE")
    if [ -z "$NOME_INSTANCIA" ]; then
        msg "$VERMELHO" "‚ùå Nome da inst√¢ncia inv√°lido na vari√°vel NEUROBOOST_INSTANCE!"
        msg "$VERMELHO" "    Use apenas letras, n√∫meros e h√≠fens."
        exit 1
    fi
    msg "$VERDE" "‚úì Nome da inst√¢ncia (vari√°vel): $NOME_INSTANCIA"
else
    # Pergunta interativamente se n√£o definida
    while true; do
        msg "$BRANCO" "Digite o nome da inst√¢ncia (ex: cliente1, empresa2):"
        msg "$AMARELO" "‚û§ Este nome ser√° usado como subdom√≠nio para todas as aplica√ß√µes"
        read -p "> " nome_instancia_raw
        
        NOME_INSTANCIA=$(validar_nome_instancia "$nome_instancia_raw")
        
        if [ -z "$NOME_INSTANCIA" ]; then
            msg "$VERMELHO" "‚ùå Nome inv√°lido! Use apenas letras, n√∫meros e h√≠fens."
            continue
        fi
        
        msg "$VERDE" "‚úì Nome da inst√¢ncia: $NOME_INSTANCIA"
        break
    done
fi

## Email para certificados SSL
echo ""
if [ -n "$NEUROBOOST_EMAIL" ]; then
    # Usa vari√°vel de ambiente se definida
    EMAIL_SSL="$NEUROBOOST_EMAIL"
    if [[ ! "$EMAIL_SSL" =~ ^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$ ]]; then
        msg "$VERMELHO" "‚ùå Email inv√°lido na vari√°vel NEUROBOOST_EMAIL!"
        exit 1
    fi
    msg "$VERDE" "‚úì Email (vari√°vel): $EMAIL_SSL"
else
    # Usa email padr√£o da Neuroboost
    EMAIL_SSL="ssl@neuroboost.digital"
    msg "$VERDE" "‚úì Email (padr√£o): $EMAIL_SSL"
fi

## Gera senhas automaticamente
msg "$AMARELO" ""
msg "$AMARELO" "üîê Gerando senhas seguras..."
PASS_PORTAINER=$(gerar_senha 16)
PASS_MINIO=$(gerar_senha 12)
PASS_TRAEFIK=$(gerar_senha 14)
PASS_POSTGRES=$(gerar_senha 16)
PASS_RABBITMQ=$(gerar_senha 16)
N8N_ENCRYPTION_KEY=$(gerar_senha 32)
PASS_CHATDIGI_JWT=$(gerar_senha 32)
PASS_CHATDIGI_REFRESH=$(gerar_senha 32)

## Define usu√°rios
USER_PORTAINER="$USUARIO_PADRAO"
USER_MINIO="$USUARIO_PADRAO"
USER_TRAEFIK="$USUARIO_PADRAO"
USER_RABBITMQ="$USUARIO_PADRAO"

## Define URLs autom√°ticas
URL_TRAEFIK="traefik.${NOME_INSTANCIA}.${DOMINIO_BASE}"
URL_PORTAINER="portainer.${NOME_INSTANCIA}.${DOMINIO_BASE}"
URL_MINIO="minio.${NOME_INSTANCIA}.${DOMINIO_BASE}"
URL_S3="s3.${NOME_INSTANCIA}.${DOMINIO_BASE}"
URL_RABBITMQ="mq.${NOME_INSTANCIA}.${DOMINIO_BASE}"
N8N_HOST="n8n.${NOME_INSTANCIA}.${DOMINIO_BASE}"
N8N_WEBHOOK_HOST="webhook.${NOME_INSTANCIA}.${DOMINIO_BASE}"
URL_CHATDIGI_FRONTEND="chat.${NOME_INSTANCIA}.${DOMINIO_BASE}"
URL_CHATDIGI_BACKEND="api.${NOME_INSTANCIA}.${DOMINIO_BASE}"

## Resumo das configura√ß√µes
echo ""
msg "$AMARELO" "=== RESUMO DAS CONFIGURA√á√ïES ==="
msg "$BRANCO" "Nome da Inst√¢ncia: $VERDE$NOME_INSTANCIA"
msg "$BRANCO" "Email SSL: $VERDE$EMAIL_SSL"
msg "$BRANCO" "Usu√°rio padr√£o: $VERDE$USUARIO_PADRAO"
msg "$BRANCO" "Fuso hor√°rio: $VERDE$(timedatectl show --property=Timezone --value)"
echo ""
msg "$BRANCO" "URLs que ser√£o criadas:"
msg "$BRANCO" "  ‚Ä¢ Traefik: $VERDE$URL_TRAEFIK"
msg "$BRANCO" "  ‚Ä¢ Portainer: $VERDE$URL_PORTAINER"
msg "$BRANCO" "  ‚Ä¢ MinIO: $VERDE$URL_MINIO"
msg "$BRANCO" "  ‚Ä¢ S3: $VERDE$URL_S3"
msg "$BRANCO" "  ‚Ä¢ RabbitMQ: $VERDE$URL_RABBITMQ"
msg "$BRANCO" "  ‚Ä¢ N8N Editor: $VERDE$N8N_HOST"
msg "$BRANCO" "  ‚Ä¢ N8N Webhook: $VERDE$N8N_WEBHOOK_HOST"
msg "$BRANCO" "  ‚Ä¢ FAQ System: $VERDE$URL_FAQ"
msg "$BRANCO" "  ‚Ä¢ ChatDigi Frontend: $VERDE$URL_CHATDIGI_FRONTEND"
msg "$BRANCO" "  ‚Ä¢ ChatDigi Backend: $VERDE$URL_CHATDIGI_BACKEND"
echo ""

if [ "$NEUROBOOST_AUTO_CONFIRM" = "true" ]; then
    # Confirma automaticamente se vari√°vel definida
    msg "$VERDE" "‚úì Confirma√ß√£o autom√°tica ativada"
    confirmar="s"
else
    # Pergunta confirma√ß√£o se n√£o definida
    read -p "Confirmar e iniciar instala√ß√£o? (s/n): " confirmar
fi

if [[ ! "$confirmar" =~ ^[Ss]$ ]]; then
    msg "$VERMELHO" "Instala√ß√£o cancelada."
    exit 1
fi

## Aguarda 5 segundos antes de iniciar
msg "$AMARELO" "‚è≥ Iniciando instala√ß√£o em 5 segundos..."
sleep 5

## ===================================================================================================
##                                    PREPARA√á√ÉO DO SISTEMA
## ===================================================================================================

clear
msg "$AMARELO" "=== PREPARANDO SISTEMA ==="
echo ""

## Atualiza sistema
msg "$BRANCO" "üì¶ Atualizando sistema..."
exec_log "apt-get update -qq" "Atualizando lista de pacotes" "true"

# Resolve problemas de pacotes em hold e conflitos
msg "$BRANCO" "üîß Resolvendo conflitos de pacotes..."
exec_log "apt-mark unhold $(apt-mark showhold)" "Removendo hold de pacotes" "false"
exec_log "dpkg --configure -a" "Configurando pacotes pendentes" "false"
exec_log "apt-get -f install -y" "Corrigindo depend√™ncias quebradas" "false"
exec_log "apt-get autoremove -y" "Removendo pacotes desnecess√°rios" "false"
exec_log "apt-get autoclean" "Limpando cache de pacotes" "false"

# Tenta instalar pacotes individualmente para identificar problemas
msg "$BRANCO" "üì¶ Instalando depend√™ncias b√°sicas..."
for package in curl jq openssl apache2-utils tzdata unzip; do
    if ! dpkg -l | grep -q "^ii  $package "; then
        msg "$AMARELO" "üì¶ Instalando $package..."
        if ! exec_log "apt-get install -y -qq $package" "Instalando $package" "false"; then
            msg "$AMARELO" "‚ö†Ô∏è  Falha ao instalar $package, tentando com --fix-missing..."
            exec_log "apt-get install -y -qq --fix-missing $package" "Instalando $package com fix-missing" "true"
        fi
    else
        msg "$VERDE" "‚úÖ $package j√° est√° instalado"
    fi
done

# Tenta instalar ntp opcionalmente (n√£o cr√≠tico)
msg "$BRANCO" "üì¶ Tentando instalar ntp (opcional)..."
if ! dpkg -l | grep -q "^ii  ntp "; then
    if exec_log "apt-get install -y -qq ntp" "Instalando ntp" "false"; then
        msg "$VERDE" "‚úÖ ntp instalado com sucesso"
    else
        msg "$AMARELO" "‚ö†Ô∏è  ntp n√£o p√¥de ser instalado, usando systemd-timesyncd"
        msg "$AMARELO" "‚ÑπÔ∏è  systemd-timesyncd √© suficiente para sincroniza√ß√£o de tempo"
    fi
else
    msg "$VERDE" "‚úÖ ntp j√° est√° instalado"
fi

msg "$VERDE" "‚úÖ Sistema atualizado"

## Configura fuso hor√°rio para Bras√≠lia
msg "$BRANCO" "üïê Configurando fuso hor√°rio para Bras√≠lia..."
exec_log "timedatectl set-timezone America/Sao_Paulo" "Definindo fuso hor√°rio para Bras√≠lia"
exec_log "timedatectl set-ntp true" "Habilitando sincroniza√ß√£o autom√°tica de tempo"
exec_log "systemctl enable systemd-timesyncd" "Habilitando servi√ßo de sincroniza√ß√£o de tempo"
exec_log "systemctl start systemd-timesyncd" "Iniciando servi√ßo de sincroniza√ß√£o de tempo"

# Aguarda sincroniza√ß√£o
msg "$AMARELO" "‚è≥ Aguardando sincroniza√ß√£o de tempo..."
sleep 5

# Verifica configura√ß√£o
current_time=$(date)
current_tz=$(timedatectl show --property=Timezone --value)
msg "$VERDE" "‚úÖ Fuso hor√°rio configurado: $current_tz"
msg "$VERDE" "‚úÖ Hor√°rio atual: $current_time"
log_message "Fuso hor√°rio configurado: $current_tz"
log_message "Hor√°rio atual: $current_time"

## Instala Docker se necess√°rio
if ! verificar_docker; then
    msg "$BRANCO" "üê≥ Instalando Docker..."
    
    # Instala Docker
    exec_log "curl -fsSL https://get.docker.com | bash" "Baixando e instalando Docker"
    
    # Habilita e inicia o servi√ßo Docker
    exec_log "systemctl enable docker" "Habilitando servi√ßo Docker"
    exec_log "systemctl start docker" "Iniciando servi√ßo Docker"
    
    # Como o script executa como root, n√£o √© necess√°rio adicionar ao grupo docker
    log_message "Executando como root - n√£o precisa adicionar ao grupo docker"
    
    # Atualiza PATH e recarrega comandos
    export PATH="/usr/bin:/usr/local/bin:$PATH"
    hash -r
    log_message "PATH atualizado: $PATH"
    
    # Aguarda o Docker inicializar completamente
    msg "$AMARELO" "‚è≥ Aguardando Docker inicializar..."
    sleep 5
    
    # For√ßa restart do Docker daemon
    exec_log "systemctl restart docker" "Reiniciando Docker daemon"
    sleep 10
    
    # Verifica m√∫ltiplas vezes se Docker est√° funcionando
    tentativas=0
    max_tentativas=6
    while [ $tentativas -lt $max_tentativas ]; do
        log_message "Tentativa $((tentativas+1))/$max_tentativas de verifica√ß√£o do Docker"
        if verificar_docker; then
            msg "$VERDE" "‚úÖ Docker instalado e funcionando"
            log_message "Docker verificado e funcionando corretamente"
            break
        fi
        msg "$AMARELO" "‚è≥ Aguardando Docker inicializar... (tentativa $((tentativas+1))/$max_tentativas)"
        sleep 10
        tentativas=$((tentativas + 1))
    done
    
    # Verifica√ß√£o final
    if ! verificar_docker; then
        msg "$VERMELHO" "‚ùå Erro: Docker n√£o est√° funcionando ap√≥s instala√ß√£o"
        log_message "ERRO: Docker n√£o funcionou ap√≥s instala√ß√£o"
        echo ""
        diagnosticar_docker
        echo ""
        msg "$AMARELO" "‚ÑπÔ∏è  Tente executar: systemctl restart docker && systemctl status docker"
        exit 1
    fi
else
    msg "$VERDE" "‚úÖ Docker j√° est√° instalado e funcionando"
    log_message "Docker j√° estava instalado e funcionando"
fi

## Cria diret√≥rio do projeto
PROJETO_DIR="/root/${NOME_INSTANCIA}"
mkdir -p "$PROJETO_DIR"
cd "$PROJETO_DIR"

## Verifica e instala htpasswd se necess√°rio
if ! command -v htpasswd &> /dev/null; then
    msg "$BRANCO" "üîß Instalando htpasswd (apache2-utils)..."
    exec_log "apt-get update -qq" "Atualizando lista de pacotes"
    exec_log "apt-get install -y -qq apache2-utils" "Instalando apache2-utils para htpasswd"
    msg "$VERDE" "‚úÖ htpasswd instalado"
else
    msg "$VERDE" "‚úÖ htpasswd j√° est√° dispon√≠vel"
fi

## Gera hash da senha do Traefik para Basic Auth
TRAEFIK_AUTH=$(htpasswd -nb $USER_TRAEFIK $PASS_TRAEFIK | sed -e 's/\$/\$\$/g')

## ===================================================================================================
##                                 CRIA√á√ÉO DO DOCKER-COMPOSE.YML
## ===================================================================================================

msg "$AMARELO" ""
msg "$AMARELO" "=== CRIANDO CONFIGURA√á√ïES ==="
echo ""

## Cria docker-compose.yml com todos os servi√ßos
## Cria arquivos docker-compose
msg "$BRANCO" "üìù Criando arquivos docker-compose..."

## Cria Traefik + Portainer juntos
cat > docker-compose.traefik-portainer.yml << EOF
version: '3.8'

services:
  traefik:
    image: traefik:v3.4.0
    container_name: ${NOME_INSTANCIA}_traefik
    restart: unless-stopped
    environment:
      - TZ=America/Sao_Paulo
    command:
      - "--api.dashboard=true"
      - "--providers.docker=true"
      - "--providers.docker.exposedbydefault=false"
      - "--entrypoints.web.address=:80"
      - "--entrypoints.web.http.redirections.entryPoint.to=websecure"
      - "--entrypoints.web.http.redirections.entryPoint.scheme=https"
      - "--entrypoints.websecure.address=:443"
      - "--certificatesresolvers.letsencryptresolver.acme.httpchallenge=true"
      - "--certificatesresolvers.letsencryptresolver.acme.httpchallenge.entrypoint=web"
      - "--certificatesresolvers.letsencryptresolver.acme.storage=/letsencrypt/acme.json"
      - "--certificatesresolvers.letsencryptresolver.acme.email=${EMAIL_SSL}"
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - "/var/run/docker.sock:/var/run/docker.sock:ro"
      - "./letsencrypt:/letsencrypt"
      - "/etc/localtime:/etc/localtime:ro"
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.traefik.rule=Host(\`${URL_TRAEFIK}\`)"
      - "traefik.http.routers.traefik.entrypoints=websecure"
      - "traefik.http.routers.traefik.tls.certresolver=letsencryptresolver"
      - "traefik.http.routers.traefik.service=api@internal"
      - "traefik.http.routers.traefik.middlewares=auth"
      - "traefik.http.middlewares.auth.basicauth.users=${TRAEFIK_AUTH}"
    networks:
      - ${NOME_INSTANCIA}_network

  portainer:
    image: portainer/portainer-ce:latest
    container_name: ${NOME_INSTANCIA}_portainer
    restart: unless-stopped
    environment:
      - TZ=America/Sao_Paulo
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
      - portainer_data:/data
      - /etc/localtime:/etc/localtime:ro
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.portainer.rule=Host(\`${URL_PORTAINER}\`)"
      - "traefik.http.routers.portainer.entrypoints=websecure"
      - "traefik.http.routers.portainer.tls.certresolver=letsencryptresolver"
      - "traefik.http.services.portainer.loadbalancer.server.port=9000"
    networks:
      - ${NOME_INSTANCIA}_network

volumes:
  portainer_data:

networks:
  ${NOME_INSTANCIA}_network:
    external: true
EOF

## Cria MinIO
cat > docker-compose.minio.yml << EOF
version: '3.8'

services:
  minio:
    image: quay.io/minio/minio:latest
    container_name: ${NOME_INSTANCIA}_minio
    restart: unless-stopped
    command: server /data --console-address ":9001"
    environment:
      - TZ=America/Sao_Paulo
      - MINIO_ROOT_USER=${USER_MINIO}
      - MINIO_ROOT_PASSWORD=${PASS_MINIO}
      - MINIO_BROWSER_REDIRECT_URL=https://${URL_MINIO}
      - MINIO_SERVER_URL=https://${URL_S3}
    volumes:
      - minio_data:/data
      - /etc/localtime:/etc/localtime:ro
    labels:
      - "traefik.enable=true"
      # Console do MinIO (porta 9001)
      - "traefik.http.routers.minio-console.rule=Host(\`${URL_MINIO}\`)"
      - "traefik.http.routers.minio-console.entrypoints=websecure"
      - "traefik.http.routers.minio-console.tls.certresolver=letsencryptresolver"
      - "traefik.http.routers.minio-console.service=minio-console-svc"
      - "traefik.http.services.minio-console-svc.loadbalancer.server.port=9001"
      # API S3 (porta 9000)
      - "traefik.http.routers.minio-api.rule=Host(\`${URL_S3}\`)"
      - "traefik.http.routers.minio-api.entrypoints=websecure"
      - "traefik.http.routers.minio-api.tls.certresolver=letsencryptresolver"
      - "traefik.http.routers.minio-api.service=minio-api-svc"
      - "traefik.http.services.minio-api-svc.loadbalancer.server.port=9000"
    networks:
      - ${NOME_INSTANCIA}_network

volumes:
  minio_data:

networks:
  ${NOME_INSTANCIA}_network:
    external: true
EOF

## Cria Redis
cat > docker-compose.redis.yml << EOF
version: '3.8'

services:
  redis:
    image: redis:latest
    container_name: ${NOME_INSTANCIA}_redis
    restart: unless-stopped
    command: [
        "redis-server",
        "--appendonly",
        "yes",
        "--port",
        "6379"
      ]
    environment:
      - TZ=America/Sao_Paulo
    volumes:
      - redis_data:/data
      - /etc/localtime:/etc/localtime:ro
    networks:
      - ${NOME_INSTANCIA}_network
    #ports:
    #  - 6379:6379

volumes:
  redis_data:
    external: true
    name: ${NOME_INSTANCIA}_redis_data

networks:
  ${NOME_INSTANCIA}_network:
    external: true
    name: ${NOME_INSTANCIA}_network
EOF

## Cria PostgreSQL
cat > docker-compose.postgres.yml << EOF
version: '3.8'

services:
  postgres:
    image: pgvector/pgvector:pg14
    container_name: ${NOME_INSTANCIA}_postgres
    restart: unless-stopped
    command: >
      postgres
      -c max_connections=1000
      -c shared_buffers=1GB
      -c effective_cache_size=3GB
      -c maintenance_work_mem=256MB
      -c checkpoint_completion_target=0.9
      -c wal_buffers=16MB
      -c default_statistics_target=100
      -c random_page_cost=1.1
      -c effective_io_concurrency=200
      -c work_mem=32MB
      -c min_wal_size=1GB
      -c max_wal_size=4GB
      -c max_worker_processes=8
      -c max_parallel_workers_per_gather=4
      -c max_parallel_workers=8
      -c max_parallel_maintenance_workers=4
    environment:
      - POSTGRES_PASSWORD=${PASS_POSTGRES}
      - TZ=America/Sao_Paulo
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - /etc/localtime:/etc/localtime:ro
    networks:
      - ${NOME_INSTANCIA}_network
    #ports:
    #  - 5432:5432

volumes:
  postgres_data:
    external: true
    name: ${NOME_INSTANCIA}_postgres_data

networks:
  ${NOME_INSTANCIA}_network:
    external: true
    name: ${NOME_INSTANCIA}_network
EOF

## Cria RabbitMQ
cat > docker-compose.rabbitmq.yml << EOF
version: '3.8'

services:
  rabbitmq:
    image: rabbitmq:management
    container_name: ${NOME_INSTANCIA}_rabbitmq
    restart: unless-stopped
    command: rabbitmq-server
    hostname: rabbitmq
    environment:
      - TZ=America/Sao_Paulo
      - RABBITMQ_DEFAULT_USER=${USER_RABBITMQ}
      - RABBITMQ_DEFAULT_PASS=${PASS_RABBITMQ}
      - RABBITMQ_ERLANG_COOKIE=f9a807f6357ab93bcd653bbaa1d99dd3
      - RABBITMQ_DEFAULT_VHOST=/
    volumes:
      - rabbitmq_data:/var/lib/rabbitmq
      - /etc/localtime:/etc/localtime:ro
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.rabbitmq.rule=Host(\`${URL_RABBITMQ}\`)"
      - "traefik.http.routers.rabbitmq.entrypoints=websecure"
      - "traefik.http.routers.rabbitmq.tls.certresolver=letsencryptresolver"
      - "traefik.http.routers.rabbitmq.service=rabbitmq"
      - "traefik.http.services.rabbitmq.loadbalancer.server.port=15672"
    networks:
      - ${NOME_INSTANCIA}_network
    #ports:
    #  - 5672:5672
    #  - 15672:15672

volumes:
  rabbitmq_data:
    external: true
    name: ${NOME_INSTANCIA}_rabbitmq_data

networks:
  ${NOME_INSTANCIA}_network:
    external: true
    name: ${NOME_INSTANCIA}_network
EOF

## Cria N8N
cat > docker-compose.n8n.yml << EOF
version: '3.8'

services:
  n8n_editor:
    image: n8nio/n8n:latest
    container_name: ${NOME_INSTANCIA}_n8n_editor
    restart: unless-stopped
    command: start
    networks:
      - ${NOME_INSTANCIA}_network
    environment:
      - DB_TYPE=postgresdb
      - DB_POSTGRESDB_DATABASE=n8n_queue
      - DB_POSTGRESDB_HOST=postgres
      - DB_POSTGRESDB_PORT=5432
      - DB_POSTGRESDB_USER=postgres
      - DB_POSTGRESDB_PASSWORD=${PASS_POSTGRES}
      - N8N_ENCRYPTION_KEY=${N8N_ENCRYPTION_KEY}
      - N8N_HOST=${N8N_HOST}
      - N8N_EDITOR_BASE_URL=https://${N8N_HOST}/
      - WEBHOOK_URL=https://${N8N_WEBHOOK_HOST}/
      - N8N_PROTOCOL=https
      - NODE_ENV=production
      - EXECUTIONS_MODE=queue
      - EXECUTIONS_TIMEOUT=3600
      - EXECUTIONS_TIMEOUT_MAX=7200
      - OFFLOAD_MANUAL_EXECUTIONS_TO_WORKERS=true
      - N8N_RUNNERS_ENABLED=true
      - N8N_RUNNERS_MODE=internal
      - N8N_REINSTALL_MISSING_PACKAGES=true
      - N8N_COMMUNITY_PACKAGES_ENABLED=true
      - N8N_NODE_PATH=/home/node/.n8n/nodes
      - N8N_ENFORCE_SETTINGS_FILE_PERMISSIONS=true
      - QUEUE_BULL_REDIS_HOST=redis
      - QUEUE_BULL_REDIS_PORT=6379
      - QUEUE_BULL_REDIS_DB=2
      - N8N_METRICS=true
      - EXECUTIONS_DATA_PRUNE=true
      - EXECUTIONS_DATA_MAX_AGE=336
      - N8N_AI_ENABLED=false
      - N8N_AI_PROVIDER=openai
      - N8N_AI_OPENAI_API_KEY=
      - NODE_FUNCTION_ALLOW_BUILTIN=*
      - NODE_FUNCTION_ALLOW_EXTERNAL=moment,lodash
      - GENERIC_TIMEZONE=America/Sao_Paulo
      - TZ=America/Sao_Paulo
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.n8n_editor.rule=Host(\`${N8N_HOST}\`)"
      - "traefik.http.routers.n8n_editor.entrypoints=websecure"
      - "traefik.http.routers.n8n_editor.priority=1"
      - "traefik.http.routers.n8n_editor.tls.certresolver=letsencryptresolver"
      - "traefik.http.routers.n8n_editor.service=n8n_editor"
      - "traefik.http.services.n8n_editor.loadbalancer.server.port=5678"
      - "traefik.http.services.n8n_editor.loadbalancer.passHostHeader=1"

  n8n_webhook:
    image: n8nio/n8n:latest
    container_name: ${NOME_INSTANCIA}_n8n_webhook
    restart: unless-stopped
    command: webhook
    networks:
      - ${NOME_INSTANCIA}_network
    environment:
      - DB_TYPE=postgresdb
      - DB_POSTGRESDB_DATABASE=n8n_queue
      - DB_POSTGRESDB_HOST=postgres
      - DB_POSTGRESDB_PORT=5432
      - DB_POSTGRESDB_USER=postgres
      - DB_POSTGRESDB_PASSWORD=${PASS_POSTGRES}
      - N8N_ENCRYPTION_KEY=${N8N_ENCRYPTION_KEY}
      - N8N_HOST=${N8N_HOST}
      - N8N_EDITOR_BASE_URL=https://${N8N_HOST}/
      - WEBHOOK_URL=https://${N8N_WEBHOOK_HOST}/
      - N8N_PROTOCOL=https
      - NODE_ENV=production
      - EXECUTIONS_MODE=queue
      - EXECUTIONS_TIMEOUT=3600
      - EXECUTIONS_TIMEOUT_MAX=7200
      - OFFLOAD_MANUAL_EXECUTIONS_TO_WORKERS=true
      - N8N_RUNNERS_ENABLED=true
      - N8N_RUNNERS_MODE=internal
      - N8N_REINSTALL_MISSING_PACKAGES=true
      - N8N_COMMUNITY_PACKAGES_ENABLED=true
      - N8N_NODE_PATH=/home/node/.n8n/nodes
      - N8N_ENFORCE_SETTINGS_FILE_PERMISSIONS=true
      - QUEUE_BULL_REDIS_HOST=redis
      - QUEUE_BULL_REDIS_PORT=6379
      - QUEUE_BULL_REDIS_DB=2
      - N8N_METRICS=true
      - EXECUTIONS_DATA_PRUNE=true
      - EXECUTIONS_DATA_MAX_AGE=336
      - N8N_AI_ENABLED=false
      - N8N_AI_PROVIDER=openai
      - N8N_AI_OPENAI_API_KEY=
      - NODE_FUNCTION_ALLOW_BUILTIN=*
      - NODE_FUNCTION_ALLOW_EXTERNAL=moment,lodash
      - GENERIC_TIMEZONE=America/Sao_Paulo
      - TZ=America/Sao_Paulo
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.n8n_webhook.rule=Host(\`${N8N_WEBHOOK_HOST}\`)"
      - "traefik.http.routers.n8n_webhook.entrypoints=websecure"
      - "traefik.http.routers.n8n_webhook.priority=1"
      - "traefik.http.routers.n8n_webhook.tls.certresolver=letsencryptresolver"
      - "traefik.http.routers.n8n_webhook.service=n8n_webhook"
      - "traefik.http.services.n8n_webhook.loadbalancer.server.port=5678"
      - "traefik.http.services.n8n_webhook.loadbalancer.passHostHeader=1"

  n8n_worker:
    image: n8nio/n8n:latest
    container_name: ${NOME_INSTANCIA}_n8n_worker
    restart: unless-stopped
    command: worker --concurrency=10
    networks:
      - ${NOME_INSTANCIA}_network
    environment:
      - DB_TYPE=postgresdb
      - DB_POSTGRESDB_DATABASE=n8n_queue
      - DB_POSTGRESDB_HOST=postgres
      - DB_POSTGRESDB_PORT=5432
      - DB_POSTGRESDB_USER=postgres
      - DB_POSTGRESDB_PASSWORD=${PASS_POSTGRES}
      - N8N_ENCRYPTION_KEY=${N8N_ENCRYPTION_KEY}
      - N8N_HOST=${N8N_HOST}
      - N8N_EDITOR_BASE_URL=https://${N8N_HOST}/
      - WEBHOOK_URL=https://${N8N_WEBHOOK_HOST}/
      - N8N_PROTOCOL=https
      - NODE_ENV=production
      - EXECUTIONS_MODE=queue
      - EXECUTIONS_TIMEOUT=3600
      - EXECUTIONS_TIMEOUT_MAX=7200
      - OFFLOAD_MANUAL_EXECUTIONS_TO_WORKERS=true
      - N8N_RUNNERS_ENABLED=true
      - N8N_RUNNERS_MODE=internal
      - N8N_REINSTALL_MISSING_PACKAGES=true
      - N8N_COMMUNITY_PACKAGES_ENABLED=true
      - N8N_NODE_PATH=/home/node/.n8n/nodes
      - N8N_ENFORCE_SETTINGS_FILE_PERMISSIONS=true
      - QUEUE_BULL_REDIS_HOST=redis
      - QUEUE_BULL_REDIS_PORT=6379
      - QUEUE_BULL_REDIS_DB=2
      - N8N_METRICS=true
      - EXECUTIONS_DATA_PRUNE=true
      - EXECUTIONS_DATA_MAX_AGE=336
      - N8N_AI_ENABLED=false
      - N8N_AI_PROVIDER=openai
      - N8N_AI_OPENAI_API_KEY=
      - NODE_FUNCTION_ALLOW_BUILTIN=*
      - NODE_FUNCTION_ALLOW_EXTERNAL=moment,lodash
      - GENERIC_TIMEZONE=America/Sao_Paulo
      - TZ=America/Sao_Paulo

networks:
  ${NOME_INSTANCIA}_network:
    external: true
    name: ${NOME_INSTANCIA}_network
EOF

## Gera senha para o usu√°rio FAQ
PASS_FAQ_USER=$(gerar_senha 16)
USER_FAQ="faq_user"

## Define URL FAQ
URL_FAQ="faq.${NOME_INSTANCIA}.${DOMINIO_BASE}"

## Cria FAQ System
cat > docker-compose.faq.yml << EOF
version: '3.8'

services:
  faq-system:
    image: ghcr.io/gmowses/faq:v1
    container_name: ${NOME_INSTANCIA}_faq_system
    restart: unless-stopped
    
    environment:
      # Banco de dados PostgreSQL
      - DB_HOST=postgres
      - DB_PORT=5432
      - DB_NAME=chatdigi
      - DB_USER=${USER_FAQ}
      - DB_PASSWORD=${PASS_FAQ_USER}
      
      # JWT
      - JWT_SECRET=${N8N_ENCRYPTION_KEY}
      
      # URLs
      - FRONTEND_URL=https://${URL_FAQ}
      - SYNC_WEBHOOK_URL=https://${N8N_WEBHOOK_HOST}/webhook/sync-rag
      
      # Configura√ß√µes da aplica√ß√£o
      - NODE_ENV=production
      - PORT=3001
      - TZ=America/Sao_Paulo

    volumes:
      - faq_logs:/app/logs

    networks:
      - ${NOME_INSTANCIA}_network

    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.faq_system.rule=Host(\`${URL_FAQ}\`)"
      - "traefik.http.routers.faq_system.entrypoints=websecure"
      - "traefik.http.routers.faq_system.tls.certresolver=letsencryptresolver"
      - "traefik.http.services.faq_system.loadbalancer.server.port=3001"

volumes:
  faq_logs:
    external: true
    name: ${NOME_INSTANCIA}_faq_logs

networks:
  ${NOME_INSTANCIA}_network:
    external: true
    name: ${NOME_INSTANCIA}_network
EOF

## Cria ChatDigi System
cat > docker-compose.chatdigi.yml << EOF
version: '3.8'

services:
  chatdigi-backend:
    image: ghcr.io/gmowses/chatdigi-backend:v1
    container_name: ${NOME_INSTANCIA}_chatdigi_backend
    restart: unless-stopped
    
    environment:
      # Whisper API
      - WHISPER_URL=http://whisper-api:9000
      
      # Banco de dados
      - DB_DIALECT=postgres
      - DB_HOST=postgres
      - DB_PORT=5432
      - DB_NAME=chatdigi
      - DB_USER=${USER_FAQ}
      - DB_PASS=${PASS_FAQ_USER}
      - DB_TIMEZONE=America/Sao_Paulo
      - DB_LOGGING=false
      - DB_POOL_MAX=${DB_POOL_MAX:-100}
      - DB_POOL_MIN=${DB_POOL_MIN:-15}
      - DB_POOL_ACQUIRE=${DB_POOL_ACQUIRE:-30000}
      - DB_POOL_IDLE=${DB_POOL_IDLE:-600000}
      
      # Redis
      - REDIS_HOST=redis
      - REDIS_PORT=6379
      - REDIS_PASSWORD=
      - REDIS_SECRET_KEY=${REDIS_SECRET_KEY:-MULTI100}
      - REDIS_URI=redis://redis:6379
      - REDIS_URI_ACK=redis://redis:6379
      - REDIS_URI_MSG_CONN=redis://redis:6379
      - REDIS_OPT_LIMITER_MAX=${REDIS_OPT_LIMITER_MAX:-1}
      - REDIS_OPT_LIMITER_DURATION=${REDIS_OPT_LIMITER_DURATION:-3000}
      
      # JWT
      - JWT_SECRET=${PASS_CHATDIGI_JWT}
      - JWT_REFRESH_SECRET=${PASS_CHATDIGI_REFRESH}
      
      # URLs
      - FRONTEND_URL=https://${URL_CHATDIGI_FRONTEND}
      - BACKEND_URL=https://${URL_CHATDIGI_BACKEND}
      
      # Configura√ß√µes da aplica√ß√£o
      - NODE_ENV=production
      - PORT=8080
      - MAX_FILE_SIZE=${MAX_FILE_SIZE:-50}
      - WHATSAPP_TIMEOUT=${WHATSAPP_TIMEOUT:-30000}
      - TZ=America/Sao_Paulo
      
      # Integra√ß√µes
      - OPENAI_API_KEY=${OPENAI_API_KEY:-}
      - GERENCIANET_CLIENT_ID=${GERENCIANET_CLIENT_ID:-}
      - GERENCIANET_CLIENT_SECRET=${GERENCIANET_CLIENT_SECRET:-}
      - GERENCIANET_SANDBOX=${GERENCIANET_SANDBOX:-true}
      - GERENCIANET_PIX_CERT=${GERENCIANET_PIX_CERT:-certificadoEfi}
      
      # Sentry (opcional)
      - SENTRY_DSN=${SENTRY_DSN:-}
      
      # S3 / MinIO (enabled for MinIO storage)
      - S3_STORAGE=DISABLE
      - S3_PROVIDER=minio
      - S3_ACCESS_KEY=chatdigiuser
      - S3_SECRET_KEY=supersecretpassword
      - S3_ENDPOINT=s3.digi.gmowses.cloud
      - S3_PORT=443
      - S3_REGION=us-da-1
      - S3_USE_SSL=true
      - S3_BUCKET=chatdigi-files

    volumes:
      - chatdigi_backend_uploads:/app/public
      - chatdigi_backend_logs:/app/logs

    networks:
      - ${NOME_INSTANCIA}_network

    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.chatdigi_backend_api.rule=Host(\`${URL_CHATDIGI_BACKEND}\`)"
      - "traefik.http.routers.chatdigi_backend_api.entrypoints=websecure"
      - "traefik.http.routers.chatdigi_backend_api.tls.certresolver=letsencryptresolver"
      - "traefik.http.services.chatdigi_backend_api.loadbalancer.server.port=8080"
      - "traefik.http.services.chatdigi_backend_api.loadbalancer.passHostHeader=true"
      - "traefik.http.routers.chatdigi_backend_api.service=chatdigi_backend_api"
      - "traefik.http.routers.chatdigi_backend_socketio.rule=Host(\`${URL_CHATDIGI_BACKEND}\`)"
      - "traefik.http.routers.chatdigi_backend_socketio.entrypoints=websecure"
      - "traefik.http.routers.chatdigi_backend_socketio.tls.certresolver=letsencryptresolver"
      - "traefik.http.services.chatdigi_backend_socketio.loadbalancer.server.port=8080"
      - "traefik.http.services.chatdigi_backend_socketio.loadbalancer.passHostHeader=true"
      - "traefik.http.routers.chatdigi_backend_socketio.service=chatdigi_backend_socketio"

  chatdigi-frontend:
    image: ghcr.io/gmowses/chatdigi-frontend:v1
    container_name: ${NOME_INSTANCIA}_chatdigi_frontend
    restart: unless-stopped
    
    environment:
      - TZ=America/Sao_Paulo
      - REACT_APP_BACKEND_URL=https://${URL_CHATDIGI_BACKEND}
      - REACT_APP_FRONTEND_URL=https://${URL_CHATDIGI_FRONTEND}
      - REACT_APP_PRIMARY_COLOR=${REACT_APP_PRIMARY_COLOR:-#FF7A00}
      - REACT_APP_SUPPORT_NUMBER=${REACT_APP_SUPPORT_NUMBER:-+55 11 99999-9999}

    networks:
      - ${NOME_INSTANCIA}_network

    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.chatdigi_frontend.rule=Host(\`${URL_CHATDIGI_FRONTEND}\`)"
      - "traefik.http.routers.chatdigi_frontend.entrypoints=websecure"
      - "traefik.http.routers.chatdigi_frontend.tls.certresolver=letsencryptresolver"
      - "traefik.http.services.chatdigi_frontend.loadbalancer.server.port=80"
      - "traefik.http.services.chatdigi_frontend.loadbalancer.passHostHeader=true"
      - "traefik.http.routers.chatdigi_frontend.service=chatdigi_frontend"

  qr-generator:
    image: mowses1997/qr-generator:latest
    container_name: ${NOME_INSTANCIA}_qr_generator
    restart: unless-stopped
    
    environment:
      - FLASK_ENV=production
      - FLASK_APP=app.py
      - TZ=America/Sao_Paulo

    networks:
      - ${NOME_INSTANCIA}_network

  whisper-api:
    image: mowses1997/whisper-api:latest
    container_name: ${NOME_INSTANCIA}_whisper_api
    restart: unless-stopped
    
    networks:
      - ${NOME_INSTANCIA}_network

volumes:
  chatdigi_backend_uploads:
    external: true
    name: ${NOME_INSTANCIA}_chatdigi_backend_uploads
  
  chatdigi_backend_logs:
    external: true
    name: ${NOME_INSTANCIA}_chatdigi_backend_logs

networks:
  ${NOME_INSTANCIA}_network:
    external: true
    name: ${NOME_INSTANCIA}_network
EOF

msg "$VERDE" "‚úÖ Arquivos docker-compose criados"



## ===================================================================================================
##                                    INICIANDO CONTAINERS
## ===================================================================================================

msg "$AMARELO" ""
msg "$AMARELO" "=== INICIANDO TODOS OS SERVI√áOS ==="
echo ""

## Cria diret√≥rio para certificados
mkdir -p letsencrypt

## Verifica se Docker est√° funcionando antes de iniciar containers
if ! verificar_docker; then
    msg "$VERMELHO" "‚ùå Docker n√£o est√° funcionando corretamente"
    diagnosticar_docker
    exit 1
fi

## Cria rede compartilhada se n√£o existir
msg "$BRANCO" "üåê Verificando rede compartilhada..."
if docker network ls --format '{{.Name}}' | grep -q "^${NOME_INSTANCIA}_network$"; then
    msg "$VERDE" "‚úÖ Rede ${NOME_INSTANCIA}_network j√° existe"
    log_message "Rede ${NOME_INSTANCIA}_network j√° existia"
else
    if exec_log "docker network create --driver bridge ${NOME_INSTANCIA}_network" "Criando rede compartilhada"; then
        msg "$VERDE" "‚úÖ Rede compartilhada criada"
        log_message "Rede compartilhada criada com sucesso"
    else
        msg "$VERMELHO" "‚ùå Erro ao criar rede"
        log_message "ERRO: Falha ao criar rede compartilhada"
        exit 1
    fi
fi

## Inicia todos os servi√ßos
msg "$BRANCO" "üöÄ Iniciando Traefik, Portainer e MinIO..."

# Inicia Traefik + Portainer juntos
msg "$AMARELO" "üì° Iniciando Traefik e Portainer..."
if exec_log "docker compose -f docker-compose.traefik-portainer.yml up -d" "Deploy do Traefik e Portainer"; then
    msg "$VERDE" "‚úÖ Traefik e Portainer iniciados"
    log_message "Traefik e Portainer iniciados com sucesso"
else
    msg "$VERMELHO" "‚ùå Erro ao iniciar Traefik e Portainer"
    log_message "ERRO: Falha ao iniciar Traefik e Portainer"
    exit 1
fi

# Aguarda Traefik e Portainer ficarem prontos
sleep 10

# Cria volume Redis
msg "$AMARELO" "üíæ Criando volume Redis..."
if exec_log "docker volume create ${NOME_INSTANCIA}_redis_data" "Criando volume Redis"; then
    msg "$VERDE" "‚úÖ Volume Redis criado"
    log_message "Volume Redis criado com sucesso"
else
    msg "$VERMELHO" "‚ùå Erro ao criar volume Redis"
    log_message "ERRO: Falha ao criar volume Redis"
    exit 1
fi

# Inicia MinIO
msg "$AMARELO" "üíæ Iniciando MinIO..."
if exec_log "docker compose -f docker-compose.minio.yml up -d" "Deploy do MinIO"; then
    msg "$VERDE" "‚úÖ MinIO iniciado"
    log_message "MinIO iniciado com sucesso"
else
    msg "$VERMELHO" "‚ùå Erro ao iniciar MinIO"
    log_message "ERRO: Falha ao iniciar MinIO"
    exit 1
fi

# Inicia Redis
msg "$AMARELO" "üî¥ Iniciando Redis..."
if exec_log "docker compose -f docker-compose.redis.yml up -d" "Deploy do Redis"; then
    msg "$VERDE" "‚úÖ Redis iniciado"
    log_message "Redis iniciado com sucesso"
else
    msg "$VERMELHO" "‚ùå Erro ao iniciar Redis"
    log_message "ERRO: Falha ao iniciar Redis"
    exit 1
fi

# Cria volume PostgreSQL
msg "$AMARELO" "üíæ Criando volume PostgreSQL..."
if exec_log "docker volume create ${NOME_INSTANCIA}_postgres_data" "Criando volume PostgreSQL"; then
    msg "$VERDE" "‚úÖ Volume PostgreSQL criado"
else
    msg "$VERMELHO" "‚ùå Erro ao criar volume PostgreSQL"
    log_message "ERRO: Falha ao criar volume PostgreSQL"
    exit 1
fi

# Cria volume RabbitMQ
msg "$AMARELO" "üì¶ Criando volume RabbitMQ..."
if exec_log "docker volume create ${NOME_INSTANCIA}_rabbitmq_data" "Criando volume RabbitMQ"; then
    msg "$VERDE" "‚úÖ Volume RabbitMQ criado"
    log_message "Volume RabbitMQ criado com sucesso"
else
    msg "$VERMELHO" "‚ùå Erro ao criar volume RabbitMQ"
    log_message "ERRO: Falha ao criar volume RabbitMQ"
    exit 1
fi

# Inicia PostgreSQL
msg "$AMARELO" "üî¥ Iniciando PostgreSQL..."
if exec_log "docker compose -f docker-compose.postgres.yml up -d" "Deploy do PostgreSQL"; then
    msg "$VERDE" "‚úÖ PostgreSQL iniciado"
    log_message "PostgreSQL iniciado com sucesso"
else
    msg "$VERMELHO" "‚ùå Erro ao iniciar PostgreSQL"
    log_message "ERRO: Falha ao iniciar PostgreSQL"
    exit 1
fi

# Aguarda PostgreSQL ficar pronto
msg "$AMARELO" "‚è≥ Aguardando PostgreSQL ficar pronto..."
sleep 15

# Cria banco de dados N8N no PostgreSQL
msg "$AMARELO" "üóÑÔ∏è Criando banco de dados N8N..."
if exec_log "docker exec ${NOME_INSTANCIA}_postgres psql -U postgres -c 'CREATE DATABASE n8n_queue;'" "Criando banco de dados N8N"; then
    msg "$VERDE" "‚úÖ Banco de dados N8N criado"
    log_message "Banco de dados N8N criado com sucesso"
else
    msg "$AMARELO" "‚ö†Ô∏è Banco de dados N8N j√° existe ou erro na cria√ß√£o"
    log_message "Banco de dados N8N j√° existia ou erro na cria√ß√£o"
fi

# Cria banco de dados ChatDigi no PostgreSQL
msg "$AMARELO" "üóÑÔ∏è Criando banco de dados ChatDigi..."
if exec_log "docker exec ${NOME_INSTANCIA}_postgres psql -U postgres -c 'CREATE DATABASE chatdigi;'" "Criando banco de dados ChatDigi"; then
    msg "$VERDE" "‚úÖ Banco de dados ChatDigi criado"
    log_message "Banco de dados ChatDigi criado com sucesso"
else
    msg "$AMARELO" "‚ö†Ô∏è Banco de dados ChatDigi j√° existe ou erro na cria√ß√£o"
    log_message "Banco de dados ChatDigi j√° existia ou erro na cria√ß√£o"
fi

# Cria usu√°rio espec√≠fico para o FAQ
msg "$AMARELO" "üë§ Criando usu√°rio FAQ..."
CREATE_USER_SQL="CREATE USER ${USER_FAQ} WITH PASSWORD '${PASS_FAQ_USER}';"
if exec_log "docker exec ${NOME_INSTANCIA}_postgres psql -U postgres -c \"${CREATE_USER_SQL}\"" "Criando usu√°rio FAQ"; then
    msg "$VERDE" "‚úÖ Usu√°rio FAQ criado"
    log_message "Usu√°rio FAQ criado com sucesso"
else
    msg "$AMARELO" "‚ö†Ô∏è Usu√°rio FAQ j√° existe ou erro na cria√ß√£o"
    log_message "Usu√°rio FAQ j√° existia ou erro na cria√ß√£o"
fi

# D√° permiss√µes totais ao usu√°rio FAQ
msg "$AMARELO" "üîë Configurando permiss√µes do usu√°rio FAQ..."
GRANT_PERMISSIONS_SQL="GRANT ALL PRIVILEGES ON DATABASE chatdigi TO ${USER_FAQ};"
if exec_log "docker exec ${NOME_INSTANCIA}_postgres psql -U postgres -c \"${GRANT_PERMISSIONS_SQL}\"" "Configurando permiss√µes"; then
    msg "$VERDE" "‚úÖ Permiss√µes configuradas"
    log_message "Permiss√µes do usu√°rio FAQ configuradas com sucesso"
else
    msg "$AMARELO" "‚ö†Ô∏è Erro ao configurar permiss√µes"
    log_message "Erro ao configurar permiss√µes do usu√°rio FAQ"
fi

# Cria extens√£o vector para embeddings
msg "$AMARELO" "üìù Criando extens√£o vector para embeddings..."

# Aguarda PostgreSQL estar completamente pronto
msg "$AMARELO" "‚è≥ Aguardando PostgreSQL ficar completamente pronto..."
tentativas=0
max_tentativas=10
while [ $tentativas -lt $max_tentativas ]; do
    if docker exec ${NOME_INSTANCIA}_postgres pg_isready -U postgres > /dev/null 2>&1; then
        msg "$VERDE" "‚úÖ PostgreSQL est√° pronto"
        break
    fi
    msg "$AMARELO" "‚è≥ PostgreSQL ainda n√£o est√° pronto... aguardando 5 segundos"
    sleep 5
    tentativas=$((tentativas + 1))
done

if [ $tentativas -eq $max_tentativas ]; then
    msg "$VERMELHO" "‚ùå PostgreSQL n√£o ficou pronto ap√≥s $max_tentativas tentativas"
    log_message "ERRO: PostgreSQL n√£o ficou pronto para criar extens√£o vector"
else
    # Cria a extens√£o vector (agora dispon√≠vel na imagem pgvector/pgvector:pg14)
    msg "$AMARELO" "üîß Criando extens√£o vector no banco chatdigi..."
    if docker exec ${NOME_INSTANCIA}_postgres psql -U postgres -d chatdigi -c 'CREATE EXTENSION IF NOT EXISTS vector;' > /dev/null 2>&1; then
        msg "$VERDE" "‚úÖ Extens√£o vector criada com sucesso"
        log_message "Extens√£o vector criada com sucesso"
    else
        msg "$AMARELO" "‚ö†Ô∏è Erro ao criar extens√£o vector"
        msg "$AMARELO" "‚ÑπÔ∏è  Verificando se a extens√£o j√° existe..."
        if docker exec ${NOME_INSTANCIA}_postgres psql -U postgres -d chatdigi -c "SELECT 1 FROM pg_extension WHERE extname = 'vector';" | grep -q "1 row"; then
            msg "$VERDE" "‚úÖ Extens√£o vector j√° estava instalada"
            log_message "Extens√£o vector j√° estava instalada"
        else
            msg "$AMARELO" "‚ö†Ô∏è Extens√£o vector n√£o p√¥de ser criada, mas isso pode n√£o afetar o funcionamento"
            log_message "Aviso: Extens√£o vector n√£o foi criada"
        fi
    fi
fi

# Inicia RabbitMQ
msg "$AMARELO" "üê∞ Iniciando RabbitMQ..."
if exec_log "docker compose -f docker-compose.rabbitmq.yml up -d" "Deploy do RabbitMQ"; then
    msg "$VERDE" "‚úÖ RabbitMQ iniciado"
    log_message "RabbitMQ iniciado com sucesso"
else
    msg "$VERMELHO" "‚ùå Erro ao iniciar RabbitMQ"
    log_message "ERRO: Falha ao iniciar RabbitMQ"
    exit 1
fi

# Inicia N8N
msg "$AMARELO" "ü§ñ Iniciando N8N..."
if exec_log "docker compose -f docker-compose.n8n.yml up -d" "Deploy do N8N"; then
    msg "$VERDE" "‚úÖ N8N iniciado"
    log_message "N8N iniciado com sucesso"
else
    msg "$VERMELHO" "‚ùå Erro ao iniciar N8N"
    log_message "ERRO: Falha ao iniciar N8N"
    exit 1
fi

# Cria volume FAQ logs
msg "$AMARELO" "üìù Criando volume FAQ logs..."
if exec_log "docker volume create ${NOME_INSTANCIA}_faq_logs" "Criando volume FAQ logs"; then
    msg "$VERDE" "‚úÖ Volume FAQ logs criado"
    log_message "Volume FAQ logs criado com sucesso"
else
    msg "$VERMELHO" "‚ùå Erro ao criar volume FAQ logs"
    log_message "ERRO: Falha ao criar volume FAQ logs"
    exit 1
fi

# Cria volumes ChatDigi
msg "$AMARELO" "üí¨ Criando volumes ChatDigi..."
if exec_log "docker volume create ${NOME_INSTANCIA}_chatdigi_backend_uploads" "Criando volume ChatDigi uploads"; then
    msg "$VERDE" "‚úÖ Volume ChatDigi uploads criado"
    log_message "Volume ChatDigi uploads criado com sucesso"
else
    msg "$VERMELHO" "‚ùå Erro ao criar volume ChatDigi uploads"
    log_message "ERRO: Falha ao criar volume ChatDigi uploads"
    exit 1
fi

if exec_log "docker volume create ${NOME_INSTANCIA}_chatdigi_backend_logs" "Criando volume ChatDigi logs"; then
    msg "$VERDE" "‚úÖ Volume ChatDigi logs criado"
    log_message "Volume ChatDigi logs criado com sucesso"
else
    msg "$VERMELHO" "‚ùå Erro ao criar volume ChatDigi logs"
    log_message "ERRO: Falha ao criar volume ChatDigi logs"
    exit 1
fi

# Inicia FAQ System
msg "$AMARELO" "‚ùì Iniciando Sistema FAQ..."
if exec_log "docker compose -f docker-compose.faq.yml up -d" "Deploy do FAQ System"; then
    msg "$VERDE" "‚úÖ Sistema FAQ iniciado"
    log_message "Sistema FAQ iniciado com sucesso"
else
    msg "$VERMELHO" "‚ùå Erro ao iniciar Sistema FAQ"
    log_message "ERRO: Falha ao iniciar Sistema FAQ"
    exit 1
fi

# Inicia ChatDigi System
msg "$AMARELO" "üí¨ Iniciando ChatDigi System..."
if exec_log "docker compose -f docker-compose.chatdigi.yml up -d" "Deploy do ChatDigi System"; then
    msg "$VERDE" "‚úÖ ChatDigi System iniciado"
    log_message "ChatDigi System iniciado com sucesso"
else
    msg "$VERMELHO" "‚ùå Erro ao iniciar ChatDigi System"
    log_message "ERRO: Falha ao iniciar ChatDigi System"
    exit 1
fi

msg "$VERDE" "‚úÖ Todos os servi√ßos iniciados com sucesso"

## Aguarda containers ficarem prontos
log_message "Aguardando containers ficarem prontos..."
aguardar_container "${NOME_INSTANCIA}_traefik"
aguardar_container "${NOME_INSTANCIA}_portainer"
aguardar_container "${NOME_INSTANCIA}_minio"
aguardar_container "${NOME_INSTANCIA}_redis"
aguardar_container "${NOME_INSTANCIA}_postgres"
aguardar_container "${NOME_INSTANCIA}_rabbitmq"
aguardar_container "${NOME_INSTANCIA}_n8n_editor"
aguardar_container "${NOME_INSTANCIA}_n8n_webhook"
aguardar_container "${NOME_INSTANCIA}_n8n_worker"
aguardar_container "${NOME_INSTANCIA}_faq_system"
aguardar_container "${NOME_INSTANCIA}_chatdigi_backend"
aguardar_container "${NOME_INSTANCIA}_chatdigi_frontend"
aguardar_container "${NOME_INSTANCIA}_qr_generator"

## ===================================================================================================
##                                    CONFIGURA√á√ÉO DO PORTAINER
## ===================================================================================================

msg "$AMARELO" ""
msg "$AMARELO" "=== CONFIGURANDO PORTAINER ==="
echo ""

sleep 20
msg "$BRANCO" "üë§ Configurando conta do Portainer..."
log_message "Configurando conta do Portainer via API"

CURL_CMD="curl -k -s -X POST \"https://$URL_PORTAINER/api/users/admin/init\" -H \"Content-Type: application/json\" -d \"{\\\"Username\\\": \\\"$USER_PORTAINER\\\", \\\"Password\\\": \\\"$PASS_PORTAINER\\\"}\""
log_message "Executando: $CURL_CMD"

RESPONSE=$(curl -k -s -X POST "https://$URL_PORTAINER/api/users/admin/init" \
    -H "Content-Type: application/json" \
    -d "{\"Username\": \"$USER_PORTAINER\", \"Password\": \"$PASS_PORTAINER\"}")

log_message "Resposta da API do Portainer: $RESPONSE"

if echo "$RESPONSE" | grep -q "\"Username\":\"$USER_PORTAINER\""; then
    msg "$VERDE" "‚úÖ Conta do Portainer criada com sucesso!"
    log_message "Conta do Portainer criada com sucesso"
elif echo "$RESPONSE" | grep -q "\"message\":\"User already exists\""; then
    msg "$VERDE" "‚úÖ Conta do Portainer j√° existe!"
    log_message "Conta do Portainer j√° existia"
elif echo "$RESPONSE" | grep -q "\"Id\".*\"Username\""; then
    msg "$VERDE" "‚úÖ Conta do Portainer configurada!"
    log_message "Conta do Portainer configurada com sucesso"
else
    msg "$AMARELO" "‚ö†Ô∏è  N√£o foi poss√≠vel criar a conta automaticamente"
    msg "$AMARELO" "‚ÑπÔ∏è  Acesse o Portainer em at√© 5 minutos para criar a conta!"
    log_message "AVISO: N√£o foi poss√≠vel criar conta do Portainer automaticamente"
fi

## ===================================================================================================
##                                      SALVANDO CONFIGURA√á√ïES
## ===================================================================================================

## Salva informa√ß√µes em arquivo
cat > credenciais.txt << EOF
===================================================
         CREDENCIAIS E INFORMA√á√ïES DE ACESSO
              NEUROBOOST DIGITAL
===================================================

Vers√£o do Script: $VERSION
Data da Instala√ß√£o: $(date)
Nome da Inst√¢ncia: $NOME_INSTANCIA
Diret√≥rio do Projeto: $PROJETO_DIR

===================================================
                 URLs DE ACESSO
===================================================

Traefik Dashboard: https://$URL_TRAEFIK
Portainer: https://$URL_PORTAINER
MinIO Console: https://$URL_MINIO
MinIO S3 API: https://$URL_S3
RabbitMQ Management: https://$URL_RABBITMQ
N8N Editor: https://$N8N_HOST
N8N Webhook: https://$N8N_WEBHOOK_HOST
FAQ System: https://$URL_FAQ
ChatDigi Frontend: https://$URL_CHATDIGI_FRONTEND
ChatDigi Backend: https://$URL_CHATDIGI_BACKEND

===================================================
                  CREDENCIAIS
===================================================

TRAEFIK DASHBOARD:
  URL: https://$URL_TRAEFIK
  Usu√°rio: $USER_TRAEFIK
  Senha: $PASS_TRAEFIK

PORTAINER:
  URL: https://$URL_PORTAINER
  Usu√°rio: $USER_PORTAINER
  Senha: $PASS_PORTAINER

MINIO:
  URL: https://$URL_MINIO
  Usu√°rio: $USER_MINIO
  Senha: $PASS_MINIO

POSTGRESQL:
  Host: localhost
  Porta: 5432
  Usu√°rio: postgres
  Senha: $PASS_POSTGRES
  Banco N8N: n8n_queue
  Banco ChatDigi: chatdigi
  Usu√°rio FAQ: $USER_FAQ
  Senha FAQ: $PASS_FAQ_USER

RABBITMQ:
  URL: https://$URL_RABBITMQ
  Usu√°rio: $USER_RABBITMQ
  Senha: $PASS_RABBITMQ
  Host: rabbitmq
  Porta AMQP: 5672
  Porta Management: 15672

N8N:
  Editor: https://$N8N_HOST
  Webhook: https://$N8N_WEBHOOK_HOST
  Chave de Criptografia: $N8N_ENCRYPTION_KEY

FAQ SYSTEM:
  URL: https://$URL_FAQ
  Banco: chatdigi
  Usu√°rio BD: $USER_FAQ
  Senha BD: $PASS_FAQ_USER
  JWT Secret: $N8N_ENCRYPTION_KEY
  Webhook Sync: https://$N8N_WEBHOOK_HOST/webhook/sync-rag

CHATDIGI SYSTEM:
  Frontend: https://$URL_CHATDIGI_FRONTEND
  Backend API: https://$URL_CHATDIGI_BACKEND
  Banco: chatdigi
  Usu√°rio BD: $USER_FAQ
  Senha BD: $PASS_FAQ_USER
  JWT Secret: $PASS_CHATDIGI_JWT
  JWT Refresh Secret: $PASS_CHATDIGI_REFRESH
  Redis: redis://redis:6379 (sem senha)

===================================================
                COMANDOS √öTEIS
===================================================

Entrar no diret√≥rio:
  cd $PROJETO_DIR

Ver status dos containers:
  docker ps

Ver logs Traefik:
  docker compose -f docker-compose.traefik-portainer.yml logs -f traefik

Ver logs Portainer:
  docker compose -f docker-compose.traefik-portainer.yml logs -f portainer

Ver logs MinIO:
  docker compose -f docker-compose.minio.yml logs -f

Ver logs Redis:
  docker compose -f docker-compose.redis.yml logs -f

Ver logs PostgreSQL:
  docker compose -f docker-compose.postgres.yml logs -f

Ver logs RabbitMQ:
  docker compose -f docker-compose.rabbitmq.yml logs -f

Ver logs N8N:
  docker compose -f docker-compose.n8n.yml logs -f

Ver logs FAQ System:
  docker compose -f docker-compose.faq.yml logs -f

Ver logs ChatDigi:
  docker compose -f docker-compose.chatdigi.yml logs -f

Parar todos os servi√ßos:
  docker compose -f docker-compose.traefik-portainer.yml down
  docker compose -f docker-compose.minio.yml down
  docker compose -f docker-compose.redis.yml down
  docker compose -f docker-compose.postgres.yml down
  docker compose -f docker-compose.rabbitmq.yml down
  docker compose -f docker-compose.n8n.yml down
docker compose -f docker-compose.faq.yml down
docker compose -f docker-compose.chatdigi.yml down

Reiniciar Traefik:
  docker compose -f docker-compose.traefik-portainer.yml restart traefik

Reiniciar Portainer:
  docker compose -f docker-compose.traefik-portainer.yml restart portainer

Reiniciar MinIO:
  docker compose -f docker-compose.minio.yml restart

Reiniciar Redis:
  docker compose -f docker-compose.redis.yml restart

Reiniciar PostgreSQL:
  docker compose -f docker-compose.postgres.yml restart

Reiniciar RabbitMQ:
  docker compose -f docker-compose.rabbitmq.yml restart

Reiniciar N8N:
  docker compose -f docker-compose.n8n.yml restart

Reiniciar FAQ System:
  docker compose -f docker-compose.faq.yml restart

Reiniciar ChatDigi:
  docker compose -f docker-compose.chatdigi.yml restart

Atualizar imagens:
  docker compose -f docker-compose.traefik-portainer.yml pull && docker compose -f docker-compose.traefik-portainer.yml up -d
  docker compose -f docker-compose.minio.yml pull && docker compose -f docker-compose.minio.yml up -d
  docker compose -f docker-compose.redis.yml pull && docker compose -f docker-compose.redis.yml up -d
  docker compose -f docker-compose.postgres.yml pull && docker compose -f docker-compose.postgres.yml up -d
  docker compose -f docker-compose.rabbitmq.yml pull && docker compose -f docker-compose.rabbitmq.yml up -d
  docker compose -f docker-compose.n8n.yml pull && docker compose -f docker-compose.n8n.yml up -d
docker compose -f docker-compose.faq.yml pull && docker compose -f docker-compose.faq.yml up -d
docker compose -f docker-compose.chatdigi.yml pull && docker compose -f docker-compose.chatdigi.yml up -d

===================================================
EOF

## Credenciais salvas apenas na pasta do cliente
log_message "Credenciais salvas em: $PROJETO_DIR/credenciais.txt"

## ===================================================================================================
##                                          FINALIZA√á√ÉO
## ===================================================================================================

clear
msg "$VERDE" "
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë           ‚úÖ INSTALA√á√ÉO CONCLU√çDA COM SUCESSO!                 ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
"

msg "$AMARELO" "=== INFORMA√á√ïES IMPORTANTES - GUARDE ESTAS CREDENCIAIS ==="
echo ""

msg "$BRANCO" "üìÇ Diret√≥rio do projeto: $VERDE$PROJETO_DIR"
echo ""

msg "$AMARELO" "üîê CREDENCIAIS DE ACESSO:"
echo ""

msg "$BRANCO" "TRAEFIK DASHBOARD:"
msg "$BRANCO" "  üåê URL: $VERDE https://$URL_TRAEFIK"
msg "$BRANCO" "  üë§ Usu√°rio: $VERDE$USER_TRAEFIK"
msg "$BRANCO" "  üîë Senha: $VERMELHO$PASS_TRAEFIK"
echo ""

msg "$BRANCO" "PORTAINER:"
msg "$BRANCO" "  üåê URL: $VERDE https://$URL_PORTAINER"
msg "$BRANCO" "  üë§ Usu√°rio: $VERDE$USER_PORTAINER"
msg "$BRANCO" "  üîë Senha: $VERMELHO$PASS_PORTAINER"
echo ""

msg "$BRANCO" "MINIO:"
msg "$BRANCO" "  üåê Console: $VERDE https://$URL_MINIO"
msg "$BRANCO" "  üåê S3 API: $VERDE https://$URL_S3"
msg "$BRANCO" "  üë§ Usu√°rio: $VERDE$USER_MINIO"
msg "$BRANCO" "  üîë Senha: $VERMELHO$PASS_MINIO"
echo ""

msg "$BRANCO" "POSTGRESQL:"
msg "$BRANCO" "  üóÑÔ∏è Host: $VERDE localhost"
msg "$BRANCO" "  üîå Porta: $VERDE 5432"
msg "$BRANCO" "  üë§ Usu√°rio: $VERDE postgres"
msg "$BRANCO" "  üîë Senha: $VERMELHO$PASS_POSTGRES"
msg "$BRANCO" "  üìä Banco N8N: $VERDE n8n_queue"
echo ""

msg "$BRANCO" "RABBITMQ:"
msg "$BRANCO" "  üåê URL: $VERDE https://$URL_RABBITMQ"
msg "$BRANCO" "  üë§ Usu√°rio: $VERDE$USER_RABBITMQ"
msg "$BRANCO" "  üîë Senha: $VERMELHO$PASS_RABBITMQ"
msg "$BRANCO" "  üóÑÔ∏è Host: $VERDE rabbitmq"
msg "$BRANCO" "  üîå Porta AMQP: $VERDE 5672"
msg "$BRANCO" "  üîå Porta Management: $VERDE 15672"
echo ""

msg "$BRANCO" "N8N:"
msg "$BRANCO" "  ü§ñ Editor: $VERDE https://$N8N_HOST"
msg "$BRANCO" "  üîó Webhook: $VERDE https://$N8N_WEBHOOK_HOST"
msg "$BRANCO" "  üîê Chave de Criptografia: $VERMELHO$N8N_ENCRYPTION_KEY"
echo ""

msg "$BRANCO" "FAQ SYSTEM:"
msg "$BRANCO" "  üåê URL: $VERDE https://$URL_FAQ"
msg "$BRANCO" "  üóÑÔ∏è Banco: $VERDE chatdigi"
msg "$BRANCO" "  üë§ Usu√°rio BD: $VERDE$USER_FAQ"
msg "$BRANCO" "  üîë Senha BD: $VERMELHO$PASS_FAQ_USER"
msg "$BRANCO" "  üîó Webhook Sync: $VERDE https://$N8N_WEBHOOK_HOST/webhook/sync-rag"
echo ""

msg "$BRANCO" "CHATDIGI SYSTEM:"
msg "$BRANCO" "  üåê Frontend: $VERDE https://$URL_CHATDIGI_FRONTEND"
msg "$BRANCO" "  üîå Backend API: $VERDE https://$URL_CHATDIGI_BACKEND"
msg "$BRANCO" "  üóÑÔ∏è Banco: $VERDE chatdigi"
msg "$BRANCO" "  üë§ Usu√°rio BD: $VERDE$USER_FAQ"
msg "$BRANCO" "  üîë Senha BD: $VERMELHO$PASS_FAQ_USER"
msg "$BRANCO" "  üîê JWT Secret: $VERMELHO$PASS_CHATDIGI_JWT"
msg "$BRANCO" "  üîÑ JWT Refresh: $VERMELHO$PASS_CHATDIGI_REFRESH"
msg "$BRANCO" "  üî¥ Redis: $VERDE redis://redis:6379 (sem senha)"
echo ""

msg "$AMARELO" "üìÑ Credenciais salvas em:"
msg "$BRANCO" "  ‚Ä¢ $PROJETO_DIR/credenciais.txt"
echo ""
msg "$AMARELO" "üìÅ Estrutura de diret√≥rios:"
msg "$BRANCO" "  ‚Ä¢ $PROJETO_DIR/ - Diret√≥rio principal do cliente"
msg "$BRANCO" "  ‚Ä¢ $PROJETO_DIR/docker-compose.traefik-portainer.yml"
msg "$BRANCO" "  ‚Ä¢ $PROJETO_DIR/docker-compose.minio.yml"
msg "$BRANCO" "  ‚Ä¢ $PROJETO_DIR/docker-compose.redis.yml"
msg "$BRANCO" "  ‚Ä¢ $PROJETO_DIR/docker-compose.postgres.yml"
msg "$BRANCO" "  ‚Ä¢ $PROJETO_DIR/docker-compose.rabbitmq.yml"
msg "$BRANCO" "  ‚Ä¢ $PROJETO_DIR/docker-compose.n8n.yml"
msg "$BRANCO" "  ‚Ä¢ $PROJETO_DIR/docker-compose.faq.yml"
msg "$BRANCO" "  ‚Ä¢ $PROJETO_DIR/docker-compose.chatdigi.yml"
msg "$BRANCO" "  ‚Ä¢ $PROJETO_DIR/credenciais.txt"
msg "$BRANCO" "  ‚Ä¢ $PROJETO_DIR/letsencrypt/ - Certificados SSL"
echo ""

msg "$AMARELO" "=== ARQUIVOS CRIADOS ==="
msg "$BRANCO" "‚Ä¢ docker-compose.traefik-portainer.yml - Traefik + Portainer"
msg "$BRANCO" "‚Ä¢ docker-compose.minio.yml - MinIO"
msg "$BRANCO" "‚Ä¢ docker-compose.redis.yml - Redis"
msg "$BRANCO" "‚Ä¢ docker-compose.postgres.yml - PostgreSQL"
msg "$BRANCO" "‚Ä¢ docker-compose.rabbitmq.yml - RabbitMQ"
msg "$BRANCO" "‚Ä¢ docker-compose.n8n.yml - N8N (Editor, Webhook, Worker)"
msg "$BRANCO" "‚Ä¢ docker-compose.faq.yml - FAQ System"
msg "$BRANCO" "‚Ä¢ docker-compose.chatdigi.yml - ChatDigi System"
msg "$BRANCO" "‚Ä¢ credenciais.txt - Todas as credenciais"
echo ""
msg "$AMARELO" "=== CONFIGURA√á√ïES DE SISTEMA ==="
msg "$BRANCO" "‚Ä¢ Fuso hor√°rio: $(timedatectl show --property=Timezone --value)"
msg "$BRANCO" "‚Ä¢ Sincroniza√ß√£o NTP: $(timedatectl show --property=NTPSynchronized --value)"
msg "$BRANCO" "‚Ä¢ Hor√°rio atual: $(date)"
echo ""

msg "$AMARELO" "=== PR√ìXIMAS APLICA√á√ïES ==="
msg "$BRANCO" "Para adicionar novas aplica√ß√µes:"
msg "$BRANCO" "1. Crie um novo arquivo docker-compose.app.yml"
msg "$BRANCO" "2. Use o padr√£o de URL: app.$NOME_INSTANCIA.$DOMINIO_BASE"
msg "$BRANCO" "3. Conecte √† rede: ${NOME_INSTANCIA}_network"
msg "$BRANCO" "4. Execute: docker compose -f docker-compose.app.yml up -d"
echo ""

msg "$AMARELO" "=== COMANDOS √öTEIS ==="
msg "$BRANCO" "‚Ä¢ Ver status geral: cd $PROJETO_DIR && docker ps"
msg "$BRANCO" "‚Ä¢ Ver logs Traefik: cd $PROJETO_DIR && docker compose -f docker-compose.traefik-portainer.yml logs -f traefik"
msg "$BRANCO" "‚Ä¢ Ver logs Portainer: cd $PROJETO_DIR && docker compose -f docker-compose.traefik-portainer.yml logs -f portainer"
msg "$BRANCO" "‚Ä¢ Ver logs MinIO: cd $PROJETO_DIR && docker compose -f docker-compose.minio.yml logs -f"
msg "$BRANCO" "‚Ä¢ Ver logs Redis: cd $PROJETO_DIR && docker compose -f docker-compose.redis.yml logs -f"
msg "$BRANCO" "‚Ä¢ Ver logs PostgreSQL: cd $PROJETO_DIR && docker compose -f docker-compose.postgres.yml logs -f"
msg "$BRANCO" "‚Ä¢ Ver logs RabbitMQ: cd $PROJETO_DIR && docker compose -f docker-compose.rabbitmq.yml logs -f"
msg "$BRANCO" "‚Ä¢ Ver logs N8N: cd $PROJETO_DIR && docker compose -f docker-compose.n8n.yml logs -f"
msg "$BRANCO" "‚Ä¢ Ver logs FAQ: cd $PROJETO_DIR && docker compose -f docker-compose.faq.yml logs -f"
msg "$BRANCO" "‚Ä¢ Ver logs ChatDigi: cd $PROJETO_DIR && docker compose -f docker-compose.chatdigi.yml logs -f"
msg "$BRANCO" "‚Ä¢ Reiniciar Traefik: cd $PROJETO_DIR && docker compose -f docker-compose.traefik-portainer.yml restart traefik"
msg "$BRANCO" "‚Ä¢ Reiniciar Portainer: cd $PROJETO_DIR && docker compose -f docker-compose.traefik-portainer.yml restart portainer"
msg "$BRANCO" "‚Ä¢ Reiniciar MinIO: cd $PROJETO_DIR && docker compose -f docker-compose.minio.yml restart"
msg "$BRANCO" "‚Ä¢ Reiniciar Redis: cd $PROJETO_DIR && docker compose -f docker-compose.redis.yml restart"
msg "$BRANCO" "‚Ä¢ Reiniciar PostgreSQL: cd $PROJETO_DIR && docker compose -f docker-compose.postgres.yml restart"
msg "$BRANCO" "‚Ä¢ Reiniciar RabbitMQ: cd $PROJETO_DIR && docker compose -f docker-compose.rabbitmq.yml restart"
msg "$BRANCO" "‚Ä¢ Reiniciar N8N: cd $PROJETO_DIR && docker compose -f docker-compose.n8n.yml restart"
msg "$BRANCO" "‚Ä¢ Reiniciar FAQ: cd $PROJETO_DIR && docker compose -f docker-compose.faq.yml restart"
msg "$BRANCO" "‚Ä¢ Reiniciar ChatDigi: cd $PROJETO_DIR && docker compose -f docker-compose.chatdigi.yml restart"
echo ""

## ===================================================================================================
##                                    CONFIGURA√á√ÉO DE BACKUP
## ===================================================================================================

msg "$AMARELO" "=== CONFIGURANDO SISTEMA DE BACKUP ==="
echo ""

## Configura√ß√µes do S3 (personaliz√°veis)
S3_ENDPOINT="${S3_ENDPOINT}"
S3_ACCESS_KEY="${S3_ACCESS_KEY}"
S3_SECRET_KEY="${S3_SECRET_KEY}"
S3_BUCKET="${NEUROBOOST_INSTANCE}"
S3_REGION="${S3_REGION:-us-da-1}"
BACKUP_INTERVAL_HOURS="${BACKUP_INTERVAL_HOURS:-24}"  # Intervalo entre backups em horas
BACKUP_RETENTION_DAYS="${BACKUP_RETENTION_DAYS:-3}"  # Reten√ß√£o de backups no S3 em dias

msg "$BRANCO" "üì¶ Criando pasta de scripts e backup autom√°tico..."
log_message "Criando pasta de scripts e backup autom√°tico"

## Cria pasta de scripts
mkdir -p "$PROJETO_DIR/scripts"

## Cria script de backup
cat > "$PROJETO_DIR/scripts/backup.sh" << 'BACKUP_SCRIPT_EOF'
#!/bin/bash

## ===================================================================================================
##                           SCRIPT DE BACKUP - NEUROBOOST DIGITAL
##                         BACKUP COMPLETO DE VOLUMES, DADOS E CONFIGURA√á√ïES
## ===================================================================================================

## Vers√£o do script
VERSION="1.0.0"

## Cores para output
AMARELO="\e[33m"
VERDE="\e[32m"
VERMELHO="\e[31m"
BRANCO="\e[97m"
AZUL="\e[34m"
RESET="\e[0m"

## Configura√ß√µes padr√£o
DATA_BACKUP=$(date +%Y%m%d_%H%M%S)
LOG_FILE="backup_${DATA_BACKUP}.log"
COMPRESSAO_NIVEL=6
MANTER_BACKUPS=7  # Manter √∫ltimos 7 backups

## Configura√ß√µes do S3
S3_ENDPOINT="$S3_ENDPOINT"
S3_ACCESS_KEY="$S3_ACCESS_KEY"
S3_SECRET_KEY="$S3_SECRET_KEY"
S3_BUCKET="${NOME_INSTANCIA}"
S3_REGION="$S3_REGION"
RETENCAO_DIAS=$BACKUP_RETENTION_DAYS  # Manter backups por X dias no S3

## Fun√ß√£o para logging
log_message() {
    local message="$1"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    echo "[$timestamp] $message" >> "$LOG_FILE"
}

## Fun√ß√£o para exibir mensagens coloridas e logar
msg() {
    local cor=$1
    local texto=$2
    local clean_text=$(echo -e "${texto}" | sed 's/\x1b\[[0-9;]*m//g')
    echo -e "${cor}${texto}${RESET}"
    log_message "$clean_text"
}

## Fun√ß√£o para verificar e instalar AWS CLI
verificar_aws_cli() {
    if ! command -v aws &> /dev/null; then
        msg "$AMARELO" "üì¶ AWS CLI n√£o encontrado, instalando..."
        
        if [[ $(uname -m) == "arm64" ]]; then
            ARCH="aarch64"
        else
            ARCH="x86_64"
        fi
        
        curl -s "https://awscli.amazonaws.com/awscli-exe-linux-${ARCH}.zip" -o "/tmp/awscliv2.zip"
        unzip -q "/tmp/awscliv2.zip" -d "/tmp/"
        /tmp/aws/install --update > /dev/null 2>&1
        rm -rf /tmp/aws /tmp/awscliv2.zip
        
        if command -v aws &> /dev/null; then
            msg "$VERDE" "‚úÖ AWS CLI instalado com sucesso"
        else
            msg "$VERMELHO" "‚ùå Falha na instala√ß√£o do AWS CLI"
            exit 1
        fi
    fi
}



## Fun√ß√£o para verificar S3
verificar_s3() {
    if aws s3 ls --endpoint-url https://$S3_ENDPOINT --profile idrivee2 > /dev/null 2>&1; then
        if aws s3 ls "s3://$S3_BUCKET" --endpoint-url https://$S3_ENDPOINT --profile idrivee2 > /dev/null 2>&1; then
            msg "$VERDE" "‚úÖ Bucket $S3_BUCKET confirmado"
        else
            msg "$VERMELHO" "‚ùå Bucket $S3_BUCKET n√£o encontrado"
            msg "$AMARELO" "‚ö†Ô∏è Verifique se o bucket existe no S3"
            exit 1
        fi
    else
        msg "$VERMELHO" "‚ùå Falha na conectividade S3"
        exit 1
    fi
}

## Fun√ß√£o para backup de volumes
backup_volumes() {
    local backup_dir=$1
    local volumes_dir="$backup_dir/volumes"
    
    msg "$AMARELO" "üíæ Iniciando backup dos volumes Docker..."
    
    local volumes=(
        "${NOME_INSTANCIA}_postgres_data"
        "${NOME_INSTANCIA}_minio_data"
        "${NOME_INSTANCIA}_redis_data"
        "${NOME_INSTANCIA}_rabbitmq_data"
        "${NOME_INSTANCIA}_n8n_data"
        "${NOME_INSTANCIA}_faq_logs"
        "${NOME_INSTANCIA}_chatdigi_backend_uploads"
        "${NOME_INSTANCIA}_chatdigi_backend_logs"
    )
    
    for volume in "${volumes[@]}"; do
        if docker volume inspect "$volume" &> /dev/null; then
            msg "$AZUL" "  üì¶ Fazendo backup do volume: $volume"
            docker run --rm -v "$volume:/source:ro" -v "$volumes_dir:/backup" alpine:latest tar czf "/backup/${volume}.tar.gz" -C /source .
            if [ $? -eq 0 ]; then
                msg "$VERDE" "    ‚úÖ Volume $volume - backup conclu√≠do"
            fi
        fi
    done
}

## Fun√ß√£o para backup dos bancos
backup_databases() {
    local backup_dir=$1
    local db_dir="$backup_dir/databases"
    
    msg "$AMARELO" "üóÑÔ∏è Iniciando backup dos bancos de dados..."
    
    if docker ps | grep -q "${NOME_INSTANCIA}_postgres"; then
        local databases=("postgres" "n8n_queue" "chatdigi")
        
        for db in "${databases[@]}"; do
            msg "$AZUL" "  üóÉÔ∏è Fazendo backup do banco: $db"
            if docker exec "${NOME_INSTANCIA}_postgres" pg_dump -U postgres "$db" > "$db_dir/${db}_${DATA_BACKUP}.sql"; then
                gzip "$db_dir/${db}_${DATA_BACKUP}.sql"
                msg "$VERDE" "    ‚úÖ Banco $db - backup conclu√≠do"
            fi
        done
        
        if docker exec "${NOME_INSTANCIA}_postgres" pg_dumpall -U postgres > "$db_dir/postgresql_global_${DATA_BACKUP}.sql"; then
            gzip "$db_dir/postgresql_global_${DATA_BACKUP}.sql"
            msg "$VERDE" "    ‚úÖ Backup global PostgreSQL conclu√≠do"
        fi
    fi
}

## Fun√ß√£o para backup das configura√ß√µes
backup_configs() {
    local backup_dir=$1
    local config_dir="$backup_dir/configs"
    
    msg "$AMARELO" "‚öôÔ∏è Iniciando backup das configura√ß√µes..."
    
    local config_files=(
        "docker-compose.traefik-portainer.yml"
        "docker-compose.minio.yml"
        "docker-compose.redis.yml"
        "docker-compose.postgres.yml"
        "docker-compose.rabbitmq.yml"
        "docker-compose.n8n.yml"
        "docker-compose.faq.yml"
        "docker-compose.chatdigi.yml"
        "credenciais.txt"
        "backup.sh"
    )
    
    for file in "${config_files[@]}"; do
        if [ -f "$file" ]; then
            cp "$file" "$config_dir/"
            msg "$VERDE" "  ‚úÖ Arquivo copiado: $file"
        fi
    done
}

## Fun√ß√£o para enviar para S3
enviar_para_s3() {
    local arquivo_backup=$1
    local nome_arquivo=$(basename "$arquivo_backup")
    
    msg "$AMARELO" "‚òÅÔ∏è Enviando backup para S3..."
    
    if aws s3 cp "$arquivo_backup" "s3://$S3_BUCKET/$nome_arquivo" --endpoint-url https://$S3_ENDPOINT --profile idrivee2; then
        local tamanho=$(du -h "$arquivo_backup" | cut -f1)
        msg "$VERDE" "‚úÖ Backup enviado para S3: $nome_arquivo ($tamanho)"
        rm -f "$arquivo_backup"
        return 0
    else
        msg "$VERMELHO" "‚ùå Falha no envio para S3"
        return 1
    fi
}

## Fun√ß√£o para limpar backups antigos no S3
limpar_s3_antigos() {
    msg "$AMARELO" "üßπ Limpando backups antigos no S3..."
    
    local data_limite=$(date -d "$RETENCAO_DIAS days ago" +%Y%m%d)
    local arquivos_s3=$(aws s3 ls "s3://$S3_BUCKET/" --endpoint-url https://$S3_ENDPOINT --profile idrivee2 | grep "backup_${NOME_INSTANCIA}_" | awk '{print $4}')
    
    local removidos=0
    for arquivo in $arquivos_s3; do
        local data_arquivo=$(echo "$arquivo" | grep -o '[0-9]\{8\}_[0-9]\{6\}' | cut -d'_' -f1)
        if [ ! -z "$data_arquivo" ] && [ "$data_arquivo" -lt "$data_limite" ]; then
            if aws s3 rm "s3://$S3_BUCKET/$arquivo" --endpoint-url https://$S3_ENDPOINT --profile idrivee2 > /dev/null 2>&1; then
                removidos=$((removidos + 1))
            fi
        fi
    done
    
    if [ $removidos -eq 0 ]; then
        msg "$VERDE" "‚úÖ Nenhum arquivo antigo encontrado para remo√ß√£o"
    else
        msg "$VERDE" "‚úÖ $removidos arquivo(s) antigo(s) removido(s) do S3"
    fi
}

## Fun√ß√£o principal
main() {
    NOME_INSTANCIA=${1:-""}
    DESTINO_BACKUP=${2:-"/tmp/neuroboost_backup"}
    
    if [ -z "$NOME_INSTANCIA" ]; then
        echo "‚ùå Nome da inst√¢ncia n√£o fornecido!"
        echo "Uso: $0 <NOME_INSTANCIA>"
        exit 1
    fi
    
    verificar_aws_cli
    verificar_s3
    
    mkdir -p "$DESTINO_BACKUP"
    local backup_dir="$DESTINO_BACKUP/backup_${NOME_INSTANCIA}_${DATA_BACKUP}"
    
    mkdir -p "$backup_dir/volumes"
    mkdir -p "$backup_dir/databases"
    mkdir -p "$backup_dir/configs"
    
    backup_volumes "$backup_dir"
    backup_databases "$backup_dir"
    backup_configs "$backup_dir"
    
    cd "$DESTINO_BACKUP"
    tar czf "backup_${NOME_INSTANCIA}_${DATA_BACKUP}.tar.gz" "backup_${NOME_INSTANCIA}_${DATA_BACKUP}"
    
    if [ $? -eq 0 ]; then
        rm -rf "backup_${NOME_INSTANCIA}_${DATA_BACKUP}"
        local arquivo_backup="$DESTINO_BACKUP/backup_${NOME_INSTANCIA}_${DATA_BACKUP}.tar.gz"
        
        if tar tzf "$arquivo_backup" > /dev/null 2>&1; then
            if enviar_para_s3 "$arquivo_backup"; then
                limpar_s3_antigos
                msg "$VERDE" "‚úÖ Backup conclu√≠do com sucesso!"
                exit 0
            fi
        fi
    fi
    
    msg "$VERMELHO" "‚ùå Backup falhou!"
    exit 1
}

main "$@"
BACKUP_SCRIPT_EOF

## Torna o script execut√°vel
chmod +x "$PROJETO_DIR/scripts/backup.sh"
msg "$VERDE" "‚úÖ Script de backup criado: $PROJETO_DIR/scripts/backup.sh"
log_message "Script de backup criado com sucesso"

## Instala AWS CLI se necess√°rio
msg "$BRANCO" "üîß Verificando AWS CLI..."
if ! command -v aws &> /dev/null; then
    msg "$AMARELO" "üì¶ Instalando AWS CLI..."
    
    # Verifica se unzip est√° dispon√≠vel
    if ! command -v unzip &> /dev/null; then
        msg "$VERMELHO" "‚ùå ERRO: comando unzip n√£o encontrado!"
        msg "$AMARELO" "‚ÑπÔ∏è  Tentando instalar unzip..."
        exec_log "apt-get update -qq" "Atualizando lista de pacotes para unzip" "true"
        exec_log "apt-get install -y -qq unzip" "Instalando unzip" "true"
    fi
    
    if [[ $(uname -m) == "arm64" ]]; then
        ARCH="aarch64"
    else
        ARCH="x86_64"
    fi
    
    exec_log "curl -s 'https://awscli.amazonaws.com/awscli-exe-linux-${ARCH}.zip' -o '/tmp/awscliv2.zip'" "Baixando AWS CLI" "true"
    exec_log "unzip -q '/tmp/awscliv2.zip' -d '/tmp/'" "Extraindo AWS CLI" "true"
    exec_log "/tmp/aws/install --update" "Instalando AWS CLI" "true"
    exec_log "rm -rf /tmp/aws /tmp/awscliv2.zip" "Limpando arquivos tempor√°rios"
    
    # Atualiza PATH para garantir que aws seja encontrado
    export PATH="/usr/local/bin:/usr/bin:$PATH"
    hash -r
    
    if command -v aws &> /dev/null; then
        msg "$VERDE" "‚úÖ AWS CLI instalado com sucesso"
        log_message "AWS CLI instalado com sucesso"
    else
        msg "$VERMELHO" "‚ùå Falha na instala√ß√£o do AWS CLI"
        log_message "ERRO: Falha na instala√ß√£o do AWS CLI"
        exit 1
    fi
else
    msg "$VERDE" "‚úÖ AWS CLI j√° est√° instalado"
fi

## Configura credenciais AWS
msg "$BRANCO" "üîë Configurando credenciais AWS..."

# Configura credenciais usando aws configure
aws configure set aws_access_key_id "$S3_ACCESS_KEY" --profile idrivee2
aws configure set aws_secret_access_key "$S3_SECRET_KEY" --profile idrivee2
aws configure set region "$S3_REGION" --profile idrivee2
aws configure set output json --profile idrivee2

# Define vari√°veis de ambiente como fallback
export AWS_ACCESS_KEY_ID="$S3_ACCESS_KEY"
export AWS_SECRET_ACCESS_KEY="$S3_SECRET_KEY"
export AWS_DEFAULT_REGION="$S3_REGION"
export AWS_PROFILE="idrivee2"

msg "$VERDE" "‚úÖ Credenciais AWS configuradas"
log_message "Credenciais AWS configuradas"

## Testa conectividade S3
msg "$BRANCO" "üîó Testando conectividade S3..."
if aws s3 ls --endpoint-url https://$S3_ENDPOINT --profile idrivee2 > /dev/null 2>&1; then
    msg "$VERDE" "‚úÖ Conectividade S3 confirmada"
    log_message "Conectividade S3 confirmada"
    
    ## Verifica bucket existente
    S3_BUCKET_FINAL="${NEUROBOOST_INSTANCE}"
    if aws s3 ls "s3://$S3_BUCKET_FINAL" --endpoint-url https://$S3_ENDPOINT --profile idrivee2 > /dev/null 2>&1; then
        msg "$VERDE" "‚úÖ Bucket $S3_BUCKET_FINAL confirmado"
        log_message "Bucket $S3_BUCKET_FINAL confirmado"
    else
        msg "$VERMELHO" "‚ùå Bucket $S3_BUCKET_FINAL n√£o encontrado"
        msg "$AMARELO" "‚ö†Ô∏è Verifique se o bucket existe no S3"
        log_message "ERRO: Bucket $S3_BUCKET_FINAL n√£o encontrado"
    fi
else
    msg "$VERMELHO" "‚ùå Falha na conectividade S3"
    msg "$AMARELO" "‚ö†Ô∏è Backup manual ainda funcionar√°, mas sem envio autom√°tico para S3"
    log_message "AVISO: Falha na conectividade S3"
fi

## Cria script de teste S3
cat > "$PROJETO_DIR/scripts/test_s3.sh" << 'TEST_S3_SCRIPT_EOF'
#!/bin/bash

## ===================================================================================================
##                           SCRIPT DE TESTE S3 - NEUROBOOST DIGITAL
##                         VERIFICA√á√ÉO DE CONECTIVIDADE E CONFIGURA√á√ÉO S3
## ===================================================================================================

## Cores para output
AMARELO="\e[33m"
VERDE="\e[32m"
VERMELHO="\e[31m"
BRANCO="\e[97m"
AZUL="\e[34m"
RESET="\e[0m"

## Configura√ß√µes do S3
S3_ENDPOINT="$S3_ENDPOINT"
S3_ACCESS_KEY="$S3_ACCESS_KEY"
S3_SECRET_KEY="$S3_SECRET_KEY"
S3_BUCKET=""
S3_REGION="$S3_REGION"

## Fun√ß√£o para exibir mensagens coloridas
msg() {
    local cor=$1
    local texto=$2
    echo -e "${cor}${texto}${RESET}"
}

## Fun√ß√£o para verificar e instalar AWS CLI
verificar_aws_cli() {
    if ! command -v aws &> /dev/null; then
        msg "$AMARELO" "üì¶ AWS CLI n√£o encontrado, instalando..."
        
        if [[ $(uname -m) == "arm64" ]]; then
            ARCH="aarch64"
        else
            ARCH="x86_64"
        fi
        
        curl -s "https://awscli.amazonaws.com/awscli-exe-linux-${ARCH}.zip" -o "/tmp/awscliv2.zip"
        unzip -q "/tmp/awscliv2.zip" -d "/tmp/"
        /tmp/aws/install --update > /dev/null 2>&1
        rm -rf /tmp/aws /tmp/awscliv2.zip
        
        if command -v aws &> /dev/null; then
            msg "$VERDE" "‚úÖ AWS CLI instalado com sucesso"
        else
            msg "$VERMELHO" "‚ùå Falha na instala√ß√£o do AWS CLI"
            exit 1
        fi
    else
        msg "$VERDE" "‚úÖ AWS CLI j√° est√° instalado"
    fi
}



## Fun√ß√£o principal
main() {
    NOME_INSTANCIA=${1:-""}
    
    if [ -z "$NOME_INSTANCIA" ]; then
        msg "$VERMELHO" "‚ùå Nome da inst√¢ncia n√£o fornecido!"
        msg "$AMARELO" "Uso: $0 <NOME_INSTANCIA>"
        exit 1
    fi
    
    S3_BUCKET="${NOME_INSTANCIA}"
    
    msg "$AMARELO" "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó"
    msg "$AMARELO" "‚ïë                    TESTE DE CONECTIVIDADE S3                   ‚ïë"
    msg "$AMARELO" "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù"
    echo ""
    
    verificar_aws_cli
    
    msg "$BRANCO" "üîó Testando conectividade S3..."
    if aws s3 ls --endpoint-url https://$S3_ENDPOINT --profile idrivee2 > /dev/null 2>&1; then
             msg "$VERDE" "‚úÖ Conectividade S3 confirmada"
             if aws s3 ls "s3://$S3_BUCKET" --endpoint-url https://$S3_ENDPOINT --profile idrivee2 > /dev/null 2>&1; then
            msg "$VERDE" "‚úÖ Bucket $S3_BUCKET confirmado"
        else
            msg "$VERMELHO" "‚ùå Bucket $S3_BUCKET n√£o encontrado"
            msg "$AMARELO" "‚ö†Ô∏è Verifique se o bucket existe no S3"
            exit 1
        fi
        
        msg "$VERDE" "‚úÖ Todos os testes S3 foram conclu√≠dos com sucesso!"
    else
        msg "$VERMELHO" "‚ùå Falha na conectividade S3"
        exit 1
    fi
}

main "$@"
TEST_S3_SCRIPT_EOF

## Torna o script de teste execut√°vel
chmod +x "$PROJETO_DIR/scripts/test_s3.sh"
msg "$VERDE" "‚úÖ Script de teste S3 criado: $PROJETO_DIR/scripts/test_s3.sh"
log_message "Script de teste S3 criado com sucesso"

## Cria script de cleanup personalizado
cat > "$PROJETO_DIR/scripts/cleanup.sh" << 'CLEANUP_SCRIPT_EOF'
#!/bin/bash

## ===================================================================================================
##                           SCRIPT DE CLEANUP - NEUROBOOST DIGITAL
##                         REMO√á√ÉO COMPLETA DE INSTALA√á√ÉO E DADOS
## ===================================================================================================

## Cores para output
AMARELO="\e[33m"
VERDE="\e[32m"
VERMELHO="\e[31m"
BRANCO="\e[97m"
AZUL="\e[34m"
RESET="\e[0m"

## Fun√ß√£o para exibir mensagens coloridas
msg() {
    local cor=$1
    local texto=$2
    echo -e "${cor}${texto}${RESET}"
}

## Fun√ß√£o para confirmar a√ß√£o
confirmar() {
    local pergunta="$1"
    echo -e "${AMARELO}${pergunta} (s/N): ${RESET}"
    read -r resposta
    [[ "$resposta" =~ ^[Ss]$ ]]
}

## Fun√ß√£o principal
main() {
    NOME_INSTANCIA=${1:-""}
    
    if [ -z "$NOME_INSTANCIA" ]; then
        msg "$VERMELHO" "‚ùå Nome da inst√¢ncia n√£o fornecido!"
        msg "$AMARELO" "Uso: $0 <NOME_INSTANCIA>"
        exit 1
    fi
    
    msg "$AMARELO" "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó"
    msg "$AMARELO" "‚ïë                    CLEANUP NEUROBOOST DIGITAL                  ‚ïë"
    msg "$AMARELO" "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù"
    echo ""
    
    msg "$VERMELHO" "‚ö†Ô∏è  ATEN√á√ÉO: Esta opera√ß√£o ir√° remover COMPLETAMENTE a instala√ß√£o!"
    msg "$BRANCO" "üìã Itens que ser√£o removidos:"
    echo "   ‚Ä¢ Todos os containers Docker da inst√¢ncia $NOME_INSTANCIA"
    echo "   ‚Ä¢ Todos os volumes Docker da inst√¢ncia"
    echo "   ‚Ä¢ Todas as redes Docker da inst√¢ncia"
    echo "   ‚Ä¢ Pasta completa do projeto: $PWD"
    echo "   ‚Ä¢ Entradas do crontab relacionadas"
    echo "   ‚Ä¢ Certificados SSL do Traefik"
    echo ""
    
    if ! confirmar "üî• Deseja REALMENTE continuar com a remo√ß√£o completa?"; then
        msg "$VERDE" "‚úÖ Opera√ß√£o cancelada pelo usu√°rio"
        exit 0
    fi
    
    msg "$AMARELO" "üõë Parando todos os containers da inst√¢ncia..."
    docker stop $(docker ps -q --filter "name=${NOME_INSTANCIA}_") 2>/dev/null || true
    
    msg "$AMARELO" "üóëÔ∏è Removendo containers da inst√¢ncia..."
    docker rm $(docker ps -aq --filter "name=${NOME_INSTANCIA}_") 2>/dev/null || true
    
    msg "$AMARELO" "üíæ Removendo volumes da inst√¢ncia..."
    docker volume rm $(docker volume ls -q --filter "name=${NOME_INSTANCIA}_") 2>/dev/null || true
    
    msg "$AMARELO" "üåê Removendo redes da inst√¢ncia..."
    docker network rm $(docker network ls -q --filter "name=${NOME_INSTANCIA}_") 2>/dev/null || true
    
    msg "$AMARELO" "‚è∞ Removendo entradas do crontab..."
    crontab -l 2>/dev/null | grep -v "${NOME_INSTANCIA}" | crontab - 2>/dev/null || true
    
    msg "$AMARELO" "üîí Removendo certificados SSL..."
    rm -rf "/etc/letsencrypt/live/${NOME_INSTANCIA}"* 2>/dev/null || true
    rm -rf "/etc/letsencrypt/archive/${NOME_INSTANCIA}"* 2>/dev/null || true
    rm -rf "/etc/letsencrypt/renewal/${NOME_INSTANCIA}"* 2>/dev/null || true
    
    msg "$AMARELO" "üìÅ Removendo pasta do projeto..."
    cd ..
    rm -rf "$PWD"
    
    msg "$VERDE" "‚úÖ Cleanup completo realizado com sucesso!"
    msg "$BRANCO" "üéØ Inst√¢ncia $NOME_INSTANCIA foi completamente removida do sistema"
}

main "$@"
CLEANUP_SCRIPT_EOF

## Torna o script de cleanup execut√°vel
chmod +x "$PROJETO_DIR/scripts/cleanup.sh"
msg "$VERDE" "‚úÖ Script de cleanup criado: $PROJETO_DIR/scripts/cleanup.sh"
log_message "Script de cleanup criado com sucesso"

## Cria script de restore com listagem de backups
cat > "$PROJETO_DIR/scripts/restore.sh" << 'RESTORE_SCRIPT_EOF'
#!/bin/bash

## ===================================================================================================
##                           SCRIPT DE RESTORE - NEUROBOOST DIGITAL
##                         LISTAGEM E RESTAURA√á√ÉO DE BACKUPS DO S3
## ===================================================================================================

## Cores para output
AMARELO="\e[33m"
VERDE="\e[32m"
VERMELHO="\e[31m"
BRANCO="\e[97m"
AZUL="\e[34m"
RESET="\e[0m"

## Configura√ß√µes do S3
S3_ENDPOINT="$S3_ENDPOINT"
S3_ACCESS_KEY="$S3_ACCESS_KEY"
S3_SECRET_KEY="$S3_SECRET_KEY"
S3_BUCKET=""
S3_REGION="$S3_REGION"

## Fun√ß√£o para exibir mensagens coloridas
msg() {
    local cor=$1
    local texto=$2
    echo -e "${cor}${texto}${RESET}"
}



## Fun√ß√£o para listar backups dispon√≠veis
listar_backups() {
    local nome_instancia=$1
    S3_BUCKET="${nome_instancia}"
    
    msg "$AMARELO" "üìã Listando backups dispon√≠veis para $nome_instancia..."
    
    local backups=$(aws s3 ls "s3://$S3_BUCKET/" --endpoint-url https://$S3_ENDPOINT --profile idrivee2 | grep "backup_${nome_instancia}_" | awk '{print $4}' | sort -r)
    
    if [ -z "$backups" ]; then
        msg "$VERMELHO" "‚ùå Nenhum backup encontrado para a inst√¢ncia $nome_instancia"
        return 1
    fi
    
    echo ""
    msg "$VERDE" "üì¶ Backups dispon√≠veis:"
    echo ""
    
    local contador=1
    declare -a lista_backups
    
    for backup in $backups; do
        local data_backup=$(echo "$backup" | grep -o '[0-9]\{8\}_[0-9]\{6\}')
        local data_formatada=$(echo "$data_backup" | sed 's/\([0-9]\{4\}\)\([0-9]\{2\}\)\([0-9]\{2\}\)_\([0-9]\{2\}\)\([0-9]\{2\}\)\([0-9]\{2\}\)/\3\/\2\/\1 \4:\5:\6/')
        local tamanho=$(aws s3 ls "s3://$S3_BUCKET/$backup" --endpoint-url https://$S3_ENDPOINT --profile idrivee2 --human-readable | awk '{print $3" "$4}')
        
        printf "   %2d) %s - %s (%s)\n" "$contador" "$data_formatada" "$backup" "$tamanho"
        lista_backups[$contador]="$backup"
        contador=$((contador + 1))
    done
    
    echo ""
    echo -e "${AMARELO}Digite o n√∫mero do backup para restaurar (0 para cancelar): ${RESET}"
    read -r escolha
    
    if [ "$escolha" = "0" ] || [ -z "$escolha" ]; then
        msg "$VERDE" "‚úÖ Opera√ß√£o cancelada"
        return 0
    fi
    
    if [ "$escolha" -ge 1 ] && [ "$escolha" -lt "$contador" ]; then
        local backup_escolhido="${lista_backups[$escolha]}"
        msg "$VERDE" "‚úÖ Backup selecionado: $backup_escolhido"
        restaurar_backup "$nome_instancia" "$backup_escolhido"
    else
        msg "$VERMELHO" "‚ùå Op√ß√£o inv√°lida"
        return 1
    fi
}

## Fun√ß√£o para restaurar backup
restaurar_backup() {
    local nome_instancia=$1
    local arquivo_backup=$2
    local temp_dir="/tmp/restore_${nome_instancia}_$(date +%s)"
    
    msg "$AMARELO" "‚¨áÔ∏è Baixando backup do S3..."
    mkdir -p "$temp_dir"
    
    if aws s3 cp "s3://$S3_BUCKET/$arquivo_backup" "$temp_dir/$arquivo_backup" --endpoint-url https://$S3_ENDPOINT --profile idrivee2; then
        msg "$VERDE" "‚úÖ Backup baixado com sucesso"
    else
        msg "$VERMELHO" "‚ùå Falha no download do backup"
        rm -rf "$temp_dir"
        return 1
    fi
    
    msg "$AMARELO" "üì¶ Extraindo backup..."
    cd "$temp_dir"
    tar xzf "$arquivo_backup"
    
    local backup_dir=$(find . -maxdepth 1 -type d -name "backup_${nome_instancia}_*" | head -1)
    
    if [ -z "$backup_dir" ]; then
        msg "$VERMELHO" "‚ùå Estrutura de backup inv√°lida"
        rm -rf "$temp_dir"
        return 1
    fi
    
    msg "$AMARELO" "üõë Parando containers da inst√¢ncia..."
    docker stop $(docker ps -q --filter "name=${nome_instancia}_") 2>/dev/null || true
    
    msg "$AMARELO" "üíæ Restaurando volumes..."
    if [ -d "$backup_dir/volumes" ]; then
        for volume_file in "$backup_dir/volumes"/*.tar.gz; do
            if [ -f "$volume_file" ]; then
                local volume_name=$(basename "$volume_file" .tar.gz)
                msg "$AZUL" "  üì¶ Restaurando volume: $volume_name"
                
                docker volume rm "$volume_name" 2>/dev/null || true
                docker volume create "$volume_name"
                docker run --rm -v "$volume_name:/target" -v "$temp_dir/$backup_dir/volumes:/backup" alpine:latest tar xzf "/backup/$(basename "$volume_file")" -C /target
            fi
        done
    fi
    
    msg "$AMARELO" "üóÑÔ∏è Restaurando bancos de dados..."
    if [ -d "$backup_dir/databases" ]; then
        ## Inicia PostgreSQL temporariamente para restore
        docker run -d --name "temp_postgres_restore" -e POSTGRES_PASSWORD=postgres -v "${nome_instancia}_postgres_data:/var/lib/postgresql/data" pgvector/pgvector:pg14
        
        ## Aguarda PostgreSQL ficar pronto
        sleep 10
        
        for db_file in "$backup_dir/databases"/*.sql.gz; do
            if [ -f "$db_file" ]; then
                local db_name=$(basename "$db_file" | sed 's/_[0-9]\{8\}_[0-9]\{6\}\.sql\.gz$//')
                if [ "$db_name" != "postgresql_global" ]; then
                    msg "$AZUL" "  üóÉÔ∏è Restaurando banco: $db_name"
                    gunzip -c "$db_file" | docker exec -i "temp_postgres_restore" psql -U postgres -d "$db_name" 2>/dev/null || true
                fi
            fi
        done
        
        docker stop "temp_postgres_restore"
        docker rm "temp_postgres_restore"
    fi
    
    msg "$AMARELO" "‚öôÔ∏è Restaurando configura√ß√µes..."
    if [ -d "$backup_dir/configs" ]; then
        cp -r "$backup_dir/configs"/* "$PWD/" 2>/dev/null || true
    fi
    
    ## Limpeza
    rm -rf "$temp_dir"
    
    msg "$VERDE" "‚úÖ Restore conclu√≠do com sucesso!"
    msg "$BRANCO" "üéØ Reinicie os servi√ßos para aplicar as altera√ß√µes"
}

## Fun√ß√£o principal
main() {
    NOME_INSTANCIA=${1:-""}
    
    if [ -z "$NOME_INSTANCIA" ]; then
        msg "$VERMELHO" "‚ùå Nome da inst√¢ncia n√£o fornecido!"
        msg "$AMARELO" "Uso: $0 <NOME_INSTANCIA>"
        exit 1
    fi
    
    if ! command -v aws &> /dev/null; then
        msg "$VERMELHO" "‚ùå AWS CLI n√£o encontrado! Execute o script de backup primeiro."
        exit 1
    fi
    
    msg "$AMARELO" "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó"
    msg "$AMARELO" "‚ïë                    RESTORE NEUROBOOST DIGITAL                  ‚ïë"
    msg "$AMARELO" "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù"
    echo ""
    
    listar_backups "$NOME_INSTANCIA"
}

main "$@"
RESTORE_SCRIPT_EOF

## Torna o script de restore execut√°vel
chmod +x "$PROJETO_DIR/scripts/restore.sh"
msg "$VERDE" "‚úÖ Script de restore criado: $PROJETO_DIR/scripts/restore.sh"
log_message "Script de restore criado com sucesso"

## Executa primeiro backup de teste
msg "$BRANCO" "üß™ Executando backup de teste..."
log_message "Iniciando backup de teste"

if "$PROJETO_DIR/scripts/backup.sh" "$NOME_INSTANCIA" > /dev/null 2>&1; then
    msg "$VERDE" "‚úÖ Backup de teste executado com sucesso"
    log_message "Backup de teste executado com sucesso"
else
    msg "$AMARELO" "‚ö†Ô∏è Backup de teste falhou, mas sistema est√° configurado"
    log_message "AVISO: Backup de teste falhou"
fi

## Configura crontab para backup autom√°tico
msg "$BRANCO" "‚è∞ Configurando backup autom√°tico (crontab)..."
log_message "Configurando crontab para backup autom√°tico"

## Calcula entrada do crontab baseada no intervalo
if [ "$BACKUP_INTERVAL_HOURS" -eq 24 ]; then
    CRONTAB_ENTRY="0 2 * * * $PROJETO_DIR/scripts/backup.sh $NOME_INSTANCIA >> /var/log/neuroboost_backup.log 2>&1"
elif [ "$BACKUP_INTERVAL_HOURS" -eq 12 ]; then
    CRONTAB_ENTRY="0 2,14 * * * $PROJETO_DIR/scripts/backup.sh $NOME_INSTANCIA >> /var/log/neuroboost_backup.log 2>&1"
elif [ "$BACKUP_INTERVAL_HOURS" -eq 6 ]; then
    CRONTAB_ENTRY="0 2,8,14,20 * * * $PROJETO_DIR/scripts/backup.sh $NOME_INSTANCIA >> /var/log/neuroboost_backup.log 2>&1"
elif [ "$BACKUP_INTERVAL_HOURS" -eq 4 ]; then
    CRONTAB_ENTRY="0 2,6,10,14,18,22 * * * $PROJETO_DIR/scripts/backup.sh $NOME_INSTANCIA >> /var/log/neuroboost_backup.log 2>&1"
else
    ## Para outros intervalos, usa a cada X horas a partir das 02:00
    CRONTAB_ENTRY="0 */$BACKUP_INTERVAL_HOURS * * * $PROJETO_DIR/scripts/backup.sh $NOME_INSTANCIA >> /var/log/neuroboost_backup.log 2>&1"
fi

## Verifica se entrada j√° existe
if crontab -l 2>/dev/null | grep -q "$PROJETO_DIR/scripts/backup.sh $NOME_INSTANCIA"; then
    msg "$VERDE" "‚úÖ Backup autom√°tico j√° est√° configurado"
    log_message "Backup autom√°tico j√° estava configurado"
else
    ## Adiciona entrada ao crontab
    (crontab -l 2>/dev/null; echo "$CRONTAB_ENTRY") | crontab -
    
    if [ $? -eq 0 ]; then
        if [ "$BACKUP_INTERVAL_HOURS" -eq 24 ]; then
            msg "$VERDE" "‚úÖ Backup autom√°tico configurado (di√°rio √†s 02:00)"
        else
            msg "$VERDE" "‚úÖ Backup autom√°tico configurado (a cada $BACKUP_INTERVAL_HOURS horas)"
        fi
        log_message "Backup autom√°tico configurado no crontab"
    else
        msg "$AMARELO" "‚ö†Ô∏è Falha ao configurar backup autom√°tico"
        log_message "AVISO: Falha ao configurar crontab"
    fi
fi

## Cria arquivo de instru√ß√µes de backup
cat > "$PROJETO_DIR/backup_instructions.txt" << EOF
===================================================
         INSTRU√á√ïES DE BACKUP - NEUROBOOST
===================================================

BACKUP AUTOM√ÅTICO:
‚Ä¢ Configurado para executar diariamente √†s 02:00
‚Ä¢ Logs salvos em: /var/log/neuroboost_backup.log
‚Ä¢ Backups enviados automaticamente para S3
‚Ä¢ Reten√ß√£o: 3 dias no S3

BACKUP MANUAL:
‚Ä¢ Execute: sudo $PROJETO_DIR/scripts/backup.sh $NOME_INSTANCIA
‚Ä¢ O backup ser√° enviado automaticamente para S3

CONFIGURA√á√ïES S3:
‚Ä¢ Endpoint: $S3_ENDPOINT
‚Ä¢ Bucket: ${NEUROBOOST_INSTANCE}
‚Ä¢ Regi√£o: $S3_REGION
‚Ä¢ Intervalo: A cada $BACKUP_INTERVAL_HOURS horas
‚Ä¢ Reten√ß√£o: $BACKUP_RETENTION_DAYS dias

SCRIPTS DISPON√çVEIS:
‚Ä¢ Backup: $PROJETO_DIR/scripts/backup.sh
‚Ä¢ Teste S3: $PROJETO_DIR/scripts/test_s3.sh
‚Ä¢ Cleanup: $PROJETO_DIR/scripts/cleanup.sh
‚Ä¢ Restore: $PROJETO_DIR/scripts/restore.sh

MONITORAMENTO:
‚Ä¢ Ver logs: tail -f /var/log/neuroboost_backup.log
‚Ä¢ Verificar crontab: crontab -l
‚Ä¢ Listar backups S3: aws s3 ls s3://${NEUROBOOST_INSTANCE}/ --endpoint-url https://$S3_ENDPOINT --profile idrivee2

COMANDOS √öTEIS:
‚Ä¢ Editar crontab: crontab -e
‚Ä¢ Remover backup autom√°tico: crontab -l | grep -v "backup.sh" | crontab -
‚Ä¢ Testar conectividade S3: aws s3 ls --endpoint-url https://$S3_ENDPOINT --profile idrivee2
‚Ä¢ Testar S3: sudo $PROJETO_DIR/scripts/test_s3.sh $NOME_INSTANCIA
‚Ä¢ Listar/Restaurar backups: sudo $PROJETO_DIR/scripts/restore.sh $NOME_INSTANCIA
‚Ä¢ Remover instala√ß√£o: sudo $PROJETO_DIR/scripts/cleanup.sh $NOME_INSTANCIA

===================================================
EOF

msg "$VERDE" "‚úÖ Sistema de backup configurado com sucesso!"
msg "$BRANCO" "üìã Instru√ß√µes salvas em: $PROJETO_DIR/backup_instructions.txt"
echo ""

msg "$AMARELO" "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó"
msg "$AMARELO" "‚ïë        NEUROBOOST DIGITAL - Automa√ß√£o e IA                     ‚ïë"
msg "$AMARELO" "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù"

## Finaliza o log
log_message "=========================================="
log_message "INSTALA√á√ÉO CONCLU√çDA COM SUCESSO"
log_message "=========================================="
log_message "Vers√£o do script: $VERSION"
log_message "Nome da inst√¢ncia: $NOME_INSTANCIA"
log_message "Traefik: https://$URL_TRAEFIK"
log_message "Portainer: https://$URL_PORTAINER"
log_message "MinIO: https://$URL_MINIO"
log_message "S3: https://$URL_S3"
log_message "RabbitMQ: https://$URL_RABBITMQ"
log_message "N8N Editor: https://$N8N_HOST"
log_message "N8N Webhook: https://$N8N_WEBHOOK_HOST"
log_message "FAQ System: https://$URL_FAQ"
log_message "ChatDigi Frontend: https://$URL_CHATDIGI_FRONTEND"
log_message "ChatDigi Backend: https://$URL_CHATDIGI_BACKEND"
log_message "PostgreSQL: localhost:5432 (bancos: n8n_queue, chatdigi)"
log_message "Fuso hor√°rio configurado: $(timedatectl show --property=Timezone --value)"
log_message "Sincroniza√ß√£o NTP: $(timedatectl show --property=NTPSynchronized --value)"
log_message "Diret√≥rio do projeto: $PROJETO_DIR"
log_message "Credenciais salvas em: $PROJETO_DIR/credenciais.txt"
log_message "Log da instala√ß√£o: $LOG_FILE"
log_message "Data/Hora de conclus√£o: $(date)"
log_message "=========================================="

msg "$AMARELO" "üìù Log detalhado salvo em: $LOG_FILE"

## Arquivos docker-compose mantidos para consulta
msg "$BRANCO" "üìÅ Arquivos docker-compose mantidos para consulta futura:"
msg "$AMARELO" "‚Ä¢ docker-compose.traefik-portainer.yml - Traefik + Portainer"
msg "$AMARELO" "‚Ä¢ docker-compose.minio.yml - MinIO"
msg "$AMARELO" "‚Ä¢ docker-compose.redis.yml - Redis"
msg "$AMARELO" "‚Ä¢ docker-compose.postgres.yml - PostgreSQL"
msg "$AMARELO" "‚Ä¢ docker-compose.rabbitmq.yml - RabbitMQ"
msg "$AMARELO" "‚Ä¢ docker-compose.n8n.yml - N8N"
msg "$AMARELO" "‚Ä¢ docker-compose.faq.yml - FAQ System"
msg "$AMARELO" "‚Ä¢ docker-compose.chatdigi.yml - ChatDigi System"
msg "$VERDE" "‚úÖ Arquivos preservados para manuten√ß√£o"