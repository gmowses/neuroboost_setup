#!/bin/bash

## ===================================================================================================
##                           INSTALADOR DOCKER COMPOSE - NEUROBOOST DIGITAL
##                              TRAEFIK + PORTAINER + MINIO + FAQ SYSTEM
## ===================================================================================================
##
## VARI√ÅVEIS DE AMBIENTE SUPORTADAS (opcionais):
##   NEUROBOOST_INSTANCE     - Nome da inst√¢ncia (ex: cliente1, empresa2) [OBRIGAT√ìRIO]
##   NEUROBOOST_EMAIL        - Email para notifica√ß√µes SSL (padr√£o: ssl@neuroboost.digital)
##   NEUROBOOST_AUTO_CONFIRM - Auto-confirmar instala√ß√£o (true/false)
##
## EXEMPLO DE USO AUTOMATIZADO:
##   export NEUROBOOST_INSTANCE="cliente1"
##   export NEUROBOOST_AUTO_CONFIRM="true"
##   bash <(curl -sSL https://raw.githubusercontent.com/gmowses/neuroboost_setup/refs/heads/main/Setup)
##
## ===================================================================================================

## Vers√£o do script (SEMVER)
VERSION="1.2.1"

## Cores
AMARELO="\e[33m"
VERDE="\e[32m"
VERMELHO="\e[31m"
BRANCO="\e[97m"
RESET="\e[0m"

## Dom√≠nio base
DOMINIO_BASE="neuroboost.digital"

## Usu√°rio padr√£o
USUARIO_PADRAO="neuroboost"

## Arquivo de log
LOG_FILE="instalacao_$(date +%Y%m%d_%H%M%S).log"

## ===================================================================================================
##                                    VERIFICA√á√ïES DE SISTEMA
## ===================================================================================================

## Fun√ß√£o para verificar requisitos do sistema
verificar_requisitos_sistema() {
    local erro=0
    
    echo "üîç Verificando requisitos do sistema..."
    
    # Verifica se est√° executando como root
    if [ "$EUID" -ne 0 ]; then
        echo "‚ùå ERRO: Este script deve ser executado como usu√°rio root!"
        echo "   Execute: sudo ./Setup"
        echo "   Usu√°rio atual: $(whoami) (UID: $EUID)"
        erro=1
    else
        echo "‚úÖ Usu√°rio root confirmado (UID: $EUID)"
    fi
    
    # Verifica se √© Ubuntu
    if [ ! -f /etc/os-release ]; then
        echo "‚ùå ERRO: N√£o foi poss√≠vel identificar o sistema operacional!"
        erro=1
    else
        # L√™ informa√ß√µes do sistema
        . /etc/os-release
        
        # Verifica se √© Ubuntu
        if [ "$ID" != "ubuntu" ]; then
            echo "‚ùå ERRO: Sistema operacional n√£o suportado!"
            echo "   Sistema detectado: $PRETTY_NAME"
            echo "   Sistema requerido: Ubuntu 24.04.2 LTS"
            erro=1
        else
            echo "‚úÖ Ubuntu detectado: $PRETTY_NAME"
            
            # Verifica vers√£o espec√≠fica do Ubuntu
            if [ "$VERSION_ID" != "24.04" ]; then
                echo "‚ùå ERRO: Vers√£o do Ubuntu n√£o suportada!"
                echo "   Vers√£o detectada: $VERSION_ID ($PRETTY_NAME)"
                echo "   Vers√£o requerida: 24.04 (Ubuntu 24.04.2 LTS)"
                erro=1
            else
                echo "‚úÖ Vers√£o do Ubuntu compat√≠vel: $VERSION_ID"
                
                # Verifica se √© LTS
                if [[ "$VERSION" != *"LTS"* ]]; then
                    echo "‚ùå ERRO: Esta n√£o √© uma vers√£o LTS do Ubuntu!"
                    echo "   Vers√£o detectada: $VERSION"
                    echo "   Requerido: Ubuntu 24.04.2 LTS"
                    erro=1
                else
                    echo "‚úÖ Ubuntu LTS confirmado: $VERSION"
                    
                    # Verifica√ß√£o adicional para patch version (recomendada)
                    if command -v lsb_release >/dev/null 2>&1; then
                        local full_version=$(lsb_release -r -s)
                        echo "‚ÑπÔ∏è  Vers√£o completa detectada: $full_version"
                        if [ "$full_version" = "24.04" ]; then
                            echo "‚úÖ Ubuntu 24.04 LTS confirmado"
                        else
                            echo "‚ö†Ô∏è  Vers√£o patch diferente detectada: $full_version"
                            echo "   Recomendado: 24.04.2, mas 24.04.x deve funcionar"
                        fi
                    fi
                fi
            fi
        fi
    fi
    
    # Se houver erro, interrompe a execu√ß√£o
    if [ $erro -eq 1 ]; then
        echo ""
        echo "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó"
        echo "‚ïë                    REQUISITOS N√ÉO ATENDIDOS                   ‚ïë"
        echo "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù"
        echo ""
        echo "‚ùå Este script s√≥ pode ser executado em:"
        echo "   ‚Ä¢ Ubuntu 24.04.2 LTS"
        echo "   ‚Ä¢ Como usu√°rio root (sudo)"
        echo ""
        echo "üîß Para corrigir:"
        echo "   1. Use Ubuntu 24.04.2 LTS"
        echo "   2. Execute: sudo ./Setup"
        echo ""
        exit 1
    fi
    
    echo ""
    echo "‚úÖ Todos os requisitos de sistema atendidos!"
    echo ""
}

## ===================================================================================================
##                                         FUN√á√ïES AUXILIARES
## ===================================================================================================

## Fun√ß√£o para logging
log_message() {
    local message="$1"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    echo "[$timestamp] $message" >> "$LOG_FILE"
}

## Fun√ß√£o para exibir mensagens coloridas e logar
msg() {
    local cor=$1
    local texto=$2
    local clean_text=$(echo -e "${texto}" | sed 's/\x1b\[[0-9;]*m//g')
    
    # Exibe no terminal com cor
    echo -e "${cor}${texto}${RESET}"
    
    # Salva no log sem cor
    log_message "$clean_text"
}

## Fun√ß√£o para executar comandos e logar
exec_log() {
    local cmd="$1"
    local description="$2"
    
    log_message "EXECUTANDO: $cmd"
    if [ -n "$description" ]; then
        log_message "DESCRI√á√ÉO: $description"
    fi
    
    # Executa comando e captura sa√≠da
    local output
    local exit_code
    
    output=$(eval "$cmd" 2>&1)
    exit_code=$?
    
    # Loga a sa√≠da
    if [ -n "$output" ]; then
        log_message "SA√çDA: $output"
    fi
    log_message "C√ìDIGO DE SA√çDA: $exit_code"
    
    # Retorna o c√≥digo de sa√≠da original
    return $exit_code
}

## Fun√ß√£o para validar nome da inst√¢ncia
validar_nome_instancia() {
    local nome=$1
    # Remove caracteres especiais e converte para min√∫sculas
    nome=$(echo "$nome" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9-]//g')
    echo "$nome"
}

## Fun√ß√£o para gerar senha segura
gerar_senha() {
    local tamanho=$1
    # Gera senha com letras mai√∫sculas, min√∫sculas, n√∫meros e caracteres especiais
    senha=$(openssl rand -base64 48 | tr -d "=+/" | cut -c1-$tamanho)
    # Garante que tenha pelo menos um de cada tipo
    senha="${senha}A1@"
    # Embaralha a senha
    senha=$(echo $senha | fold -w1 | shuf | tr -d '\n' | cut -c1-$tamanho)
    echo "$senha"
}

## Fun√ß√£o para verificar se Docker est√° instalado e funcionando
verificar_docker() {
    # Verifica se o comando docker existe
    if ! command -v docker &> /dev/null; then
        log_message "Docker comando n√£o encontrado"
        return 1
    fi
    
    # Verifica se o Docker daemon est√° rodando
    if ! docker info &> /dev/null; then
        log_message "Docker daemon n√£o est√° rodando ou n√£o responde"
        return 1
    fi
    
    # Testa se consegue executar um comando b√°sico
    if ! docker ps &> /dev/null; then
        log_message "Docker ps falhou - problemas de conectividade com daemon"
        return 1
    fi
    
    log_message "Docker verificado e funcionando corretamente"
    return 0
}

## Fun√ß√£o para diagnosticar problemas do Docker
diagnosticar_docker() {
    msg "$AMARELO" "üîç Diagnosticando problemas do Docker..."
    
    echo "üìç Verificando comando docker:"
    which docker || echo "‚ùå Comando docker n√£o encontrado"
    
    echo ""
    echo "üìç Status do servi√ßo Docker:"
    systemctl status docker --no-pager -l || echo "‚ùå Erro ao verificar status"
    
    echo ""
    echo "üìç Tentando executar docker version:"
    docker version || echo "‚ùå Erro ao executar docker version"
    
    echo ""
    echo "üìç Tentando executar docker info:"
    docker info || echo "‚ùå Erro ao executar docker info"
    
    echo ""
    echo "üìç Verificando se o socket existe:"
    ls -la /var/run/docker.sock || echo "‚ùå Socket n√£o encontrado"
}





## Fun√ß√£o para aguardar container ficar healthy
aguardar_container() {
    local container=$1
    local tentativas=0
    local max_tentativas=30
    
    msg "$AMARELO" "‚è≥ Aguardando $container ficar online..."
    log_message "Aguardando container $container ficar online"
    
    while [ $tentativas -lt $max_tentativas ]; do
        if docker ps --filter "name=$container" --filter "status=running" | grep -q "$container"; then
            msg "$VERDE" "‚úÖ Container $container est√° online!"
            log_message "Container $container est√° online com sucesso"
            return 0
        fi
        sleep 5
        tentativas=$((tentativas + 1))
        
        # Mostra progresso a cada 6 tentativas (30 segundos)
        if [ $((tentativas % 6)) -eq 0 ]; then
            msg "$AMARELO" "‚è≥ Ainda aguardando $container... ($tentativas/$max_tentativas)"
            log_message "Aguardando container $container... ($tentativas/$max_tentativas)"
        fi
    done
    
    msg "$VERMELHO" "‚ùå Timeout aguardando $container"
    log_message "ERRO: Timeout aguardando container $container"
    msg "$AMARELO" "üîç Status do container:"
    
    # Captura status do container para o log
    container_status=$(docker ps -a --filter "name=$container" 2>&1)
    log_message "Status do container $container: $container_status"
    docker ps -a --filter "name=$container" || echo "‚ùå Erro ao verificar container"
    
    if docker ps -a --filter "name=$container" | grep -q "$container"; then
        msg "$AMARELO" "üìù Logs do container:"
        container_logs=$(docker logs --tail 20 "$container" 2>&1)
        log_message "Logs do container $container: $container_logs"
        docker logs --tail 20 "$container" || echo "‚ùå Erro ao obter logs"
    fi
    return 1
}

## ===================================================================================================
##                                         COLETA DE INFORMA√á√ïES
## ===================================================================================================

## ===================================================================================================
##                                    VERIFICA√á√ÉO DE REQUISITOS
## ===================================================================================================

# Verifica requisitos ANTES de inicializar qualquer coisa
verificar_requisitos_sistema

## ===================================================================================================
##                                       INICIALIZA√á√ÉO DO LOG
## ===================================================================================================

# Inicializa o arquivo de log
log_message "=========================================="
log_message "IN√çCIO DA INSTALA√á√ÉO - NEUROBOOST DIGITAL"
log_message "=========================================="
log_message "Vers√£o do script: $VERSION"
log_message "Data/Hora: $(date)"
log_message "Usu√°rio: $(whoami)"
log_message "Diret√≥rio: $(pwd)"
log_message "Sistema: $(uname -a)"
log_message "Arquivo de log: $LOG_FILE"
log_message "Requisitos de sistema verificados e aprovados"
msg "$BRANCO" "
‚ñà‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó
‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïê‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù
‚ñà‚ñà‚ïî‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïë   
‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù  ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ïö‚ïê‚ïê‚ïê‚ïê‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë   
‚ñà‚ñà‚ïë ‚ïö‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë   
‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù   ‚ïö‚ïê‚ïù   

        INSTALADOR DOCKER COMPOSE - TRAEFIK + PORTAINER + MINIO
                              VERS√ÉO: $VERSION
"

msg "$VERDE" "‚úÖ Sistema compat√≠vel: Ubuntu 24.04 LTS como root"
msg "$AMARELO" "üìù Log da instala√ß√£o: $LOG_FILE"

msg "$AMARELO" "=== CONFIGURA√á√ÉO INICIAL ==="
echo ""

## Nome da inst√¢ncia
if [ -n "$NEUROBOOST_INSTANCE" ]; then
    # Usa vari√°vel de ambiente se definida
    NOME_INSTANCIA=$(validar_nome_instancia "$NEUROBOOST_INSTANCE")
    if [ -z "$NOME_INSTANCIA" ]; then
        msg "$VERMELHO" "‚ùå Nome da inst√¢ncia inv√°lido na vari√°vel NEUROBOOST_INSTANCE!"
        msg "$VERMELHO" "    Use apenas letras, n√∫meros e h√≠fens."
        exit 1
    fi
    msg "$VERDE" "‚úì Nome da inst√¢ncia (vari√°vel): $NOME_INSTANCIA"
else
    # Pergunta interativamente se n√£o definida
    while true; do
        msg "$BRANCO" "Digite o nome da inst√¢ncia (ex: cliente1, empresa2):"
        msg "$AMARELO" "‚û§ Este nome ser√° usado como subdom√≠nio para todas as aplica√ß√µes"
        read -p "> " nome_instancia_raw
        
        NOME_INSTANCIA=$(validar_nome_instancia "$nome_instancia_raw")
        
        if [ -z "$NOME_INSTANCIA" ]; then
            msg "$VERMELHO" "‚ùå Nome inv√°lido! Use apenas letras, n√∫meros e h√≠fens."
            continue
        fi
        
        msg "$VERDE" "‚úì Nome da inst√¢ncia: $NOME_INSTANCIA"
        break
    done
fi

## Email para certificados SSL
echo ""
if [ -n "$NEUROBOOST_EMAIL" ]; then
    # Usa vari√°vel de ambiente se definida
    EMAIL_SSL="$NEUROBOOST_EMAIL"
    if [[ ! "$EMAIL_SSL" =~ ^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$ ]]; then
        msg "$VERMELHO" "‚ùå Email inv√°lido na vari√°vel NEUROBOOST_EMAIL!"
        exit 1
    fi
    msg "$VERDE" "‚úì Email (vari√°vel): $EMAIL_SSL"
else
    # Usa email padr√£o da Neuroboost
    EMAIL_SSL="ssl@neuroboost.digital"
    msg "$VERDE" "‚úì Email (padr√£o): $EMAIL_SSL"
fi

## Gera senhas automaticamente
msg "$AMARELO" ""
msg "$AMARELO" "üîê Gerando senhas seguras..."
PASS_PORTAINER=$(gerar_senha 16)
PASS_MINIO=$(gerar_senha 12)
PASS_TRAEFIK=$(gerar_senha 14)
PASS_POSTGRES=$(gerar_senha 16)
PASS_RABBITMQ=$(gerar_senha 16)
N8N_ENCRYPTION_KEY=$(gerar_senha 32)
PASS_CHATDIGI_JWT=$(gerar_senha 32)
PASS_CHATDIGI_REFRESH=$(gerar_senha 32)

## Define usu√°rios
USER_PORTAINER="$USUARIO_PADRAO"
USER_MINIO="$USUARIO_PADRAO"
USER_TRAEFIK="$USUARIO_PADRAO"
USER_RABBITMQ="$USUARIO_PADRAO"

## Define URLs autom√°ticas
URL_TRAEFIK="traefik.${NOME_INSTANCIA}.${DOMINIO_BASE}"
URL_PORTAINER="portainer.${NOME_INSTANCIA}.${DOMINIO_BASE}"
URL_MINIO="minio.${NOME_INSTANCIA}.${DOMINIO_BASE}"
URL_S3="s3.${NOME_INSTANCIA}.${DOMINIO_BASE}"
URL_RABBITMQ="mq.${NOME_INSTANCIA}.${DOMINIO_BASE}"
N8N_HOST="n8n.${NOME_INSTANCIA}.${DOMINIO_BASE}"
N8N_WEBHOOK_HOST="webhook.${NOME_INSTANCIA}.${DOMINIO_BASE}"
URL_CHATDIGI_FRONTEND="chat.${NOME_INSTANCIA}.${DOMINIO_BASE}"
URL_CHATDIGI_BACKEND="api.${NOME_INSTANCIA}.${DOMINIO_BASE}"

## Resumo das configura√ß√µes
echo ""
msg "$AMARELO" "=== RESUMO DAS CONFIGURA√á√ïES ==="
msg "$BRANCO" "Nome da Inst√¢ncia: $VERDE$NOME_INSTANCIA"
msg "$BRANCO" "Email SSL: $VERDE$EMAIL_SSL"
msg "$BRANCO" "Usu√°rio padr√£o: $VERDE$USUARIO_PADRAO"
msg "$BRANCO" "Fuso hor√°rio: $VERDE$(timedatectl show --property=Timezone --value)"
echo ""
msg "$BRANCO" "URLs que ser√£o criadas:"
msg "$BRANCO" "  ‚Ä¢ Traefik: $VERDE$URL_TRAEFIK"
msg "$BRANCO" "  ‚Ä¢ Portainer: $VERDE$URL_PORTAINER"
msg "$BRANCO" "  ‚Ä¢ MinIO: $VERDE$URL_MINIO"
msg "$BRANCO" "  ‚Ä¢ S3: $VERDE$URL_S3"
msg "$BRANCO" "  ‚Ä¢ RabbitMQ: $VERDE$URL_RABBITMQ"
msg "$BRANCO" "  ‚Ä¢ N8N Editor: $VERDE$N8N_HOST"
msg "$BRANCO" "  ‚Ä¢ N8N Webhook: $VERDE$N8N_WEBHOOK_HOST"
msg "$BRANCO" "  ‚Ä¢ FAQ System: $VERDE$URL_FAQ"
msg "$BRANCO" "  ‚Ä¢ ChatDigi Frontend: $VERDE$URL_CHATDIGI_FRONTEND"
msg "$BRANCO" "  ‚Ä¢ ChatDigi Backend: $VERDE$URL_CHATDIGI_BACKEND"
echo ""

if [ "$NEUROBOOST_AUTO_CONFIRM" = "true" ]; then
    # Confirma automaticamente se vari√°vel definida
    msg "$VERDE" "‚úì Confirma√ß√£o autom√°tica ativada"
    confirmar="s"
else
    # Pergunta confirma√ß√£o se n√£o definida
    read -p "Confirmar e iniciar instala√ß√£o? (s/n): " confirmar
fi

if [[ ! "$confirmar" =~ ^[Ss]$ ]]; then
    msg "$VERMELHO" "Instala√ß√£o cancelada."
    exit 1
fi

## Aguarda 5 segundos antes de iniciar
msg "$AMARELO" "‚è≥ Iniciando instala√ß√£o em 5 segundos..."
sleep 5

## ===================================================================================================
##                                    PREPARA√á√ÉO DO SISTEMA
## ===================================================================================================

clear
msg "$AMARELO" "=== PREPARANDO SISTEMA ==="
echo ""

## Atualiza sistema
msg "$BRANCO" "üì¶ Atualizando sistema..."
exec_log "apt-get update -qq" "Atualizando lista de pacotes"
exec_log "apt-get install -y -qq curl jq openssl apache2-utils tzdata ntp" "Instalando depend√™ncias b√°sicas e ferramentas de tempo"
msg "$VERDE" "‚úÖ Sistema atualizado"

## Configura fuso hor√°rio para Bras√≠lia
msg "$BRANCO" "üïê Configurando fuso hor√°rio para Bras√≠lia..."
exec_log "timedatectl set-timezone America/Sao_Paulo" "Definindo fuso hor√°rio para Bras√≠lia"
exec_log "timedatectl set-ntp true" "Habilitando sincroniza√ß√£o autom√°tica de tempo"
exec_log "systemctl enable systemd-timesyncd" "Habilitando servi√ßo de sincroniza√ß√£o de tempo"
exec_log "systemctl start systemd-timesyncd" "Iniciando servi√ßo de sincroniza√ß√£o de tempo"

# Aguarda sincroniza√ß√£o
msg "$AMARELO" "‚è≥ Aguardando sincroniza√ß√£o de tempo..."
sleep 5

# Verifica configura√ß√£o
current_time=$(date)
current_tz=$(timedatectl show --property=Timezone --value)
msg "$VERDE" "‚úÖ Fuso hor√°rio configurado: $current_tz"
msg "$VERDE" "‚úÖ Hor√°rio atual: $current_time"
log_message "Fuso hor√°rio configurado: $current_tz"
log_message "Hor√°rio atual: $current_time"

## Instala Docker se necess√°rio
if ! verificar_docker; then
    msg "$BRANCO" "üê≥ Instalando Docker..."
    
    # Instala Docker
    exec_log "curl -fsSL https://get.docker.com | bash" "Baixando e instalando Docker"
    
    # Habilita e inicia o servi√ßo Docker
    exec_log "systemctl enable docker" "Habilitando servi√ßo Docker"
    exec_log "systemctl start docker" "Iniciando servi√ßo Docker"
    
    # Como o script executa como root, n√£o √© necess√°rio adicionar ao grupo docker
    log_message "Executando como root - n√£o precisa adicionar ao grupo docker"
    
    # Atualiza PATH e recarrega comandos
    export PATH="/usr/bin:/usr/local/bin:$PATH"
    hash -r
    log_message "PATH atualizado: $PATH"
    
    # Aguarda o Docker inicializar completamente
    msg "$AMARELO" "‚è≥ Aguardando Docker inicializar..."
    sleep 5
    
    # For√ßa restart do Docker daemon
    exec_log "systemctl restart docker" "Reiniciando Docker daemon"
    sleep 10
    
    # Verifica m√∫ltiplas vezes se Docker est√° funcionando
    tentativas=0
    max_tentativas=6
    while [ $tentativas -lt $max_tentativas ]; do
        log_message "Tentativa $((tentativas+1))/$max_tentativas de verifica√ß√£o do Docker"
        if verificar_docker; then
            msg "$VERDE" "‚úÖ Docker instalado e funcionando"
            log_message "Docker verificado e funcionando corretamente"
            break
        fi
        msg "$AMARELO" "‚è≥ Aguardando Docker inicializar... (tentativa $((tentativas+1))/$max_tentativas)"
        sleep 10
        tentativas=$((tentativas + 1))
    done
    
    # Verifica√ß√£o final
    if ! verificar_docker; then
        msg "$VERMELHO" "‚ùå Erro: Docker n√£o est√° funcionando ap√≥s instala√ß√£o"
        log_message "ERRO: Docker n√£o funcionou ap√≥s instala√ß√£o"
        echo ""
        diagnosticar_docker
        echo ""
        msg "$AMARELO" "‚ÑπÔ∏è  Tente executar: systemctl restart docker && systemctl status docker"
        exit 1
    fi
else
    msg "$VERDE" "‚úÖ Docker j√° est√° instalado e funcionando"
    log_message "Docker j√° estava instalado e funcionando"
fi

## Cria diret√≥rio do projeto
PROJETO_DIR="/root/${NOME_INSTANCIA}"
mkdir -p "$PROJETO_DIR"
cd "$PROJETO_DIR"

## Verifica e instala htpasswd se necess√°rio
if ! command -v htpasswd &> /dev/null; then
    msg "$BRANCO" "üîß Instalando htpasswd (apache2-utils)..."
    exec_log "apt-get update -qq" "Atualizando lista de pacotes"
    exec_log "apt-get install -y -qq apache2-utils" "Instalando apache2-utils para htpasswd"
    msg "$VERDE" "‚úÖ htpasswd instalado"
else
    msg "$VERDE" "‚úÖ htpasswd j√° est√° dispon√≠vel"
fi

## Gera hash da senha do Traefik para Basic Auth
TRAEFIK_AUTH=$(htpasswd -nb $USER_TRAEFIK $PASS_TRAEFIK | sed -e 's/\$/\$\$/g')

## ===================================================================================================
##                                 CRIA√á√ÉO DO DOCKER-COMPOSE.YML
## ===================================================================================================

msg "$AMARELO" ""
msg "$AMARELO" "=== CRIANDO CONFIGURA√á√ïES ==="
echo ""

## Cria docker-compose.yml com todos os servi√ßos
## Cria arquivos docker-compose
msg "$BRANCO" "üìù Criando arquivos docker-compose..."

## Cria Traefik + Portainer juntos
cat > docker-compose.traefik-portainer.yml << EOF
version: '3.8'

services:
  traefik:
    image: traefik:v3.4.0
    container_name: ${NOME_INSTANCIA}_traefik
    restart: unless-stopped
    environment:
      - TZ=America/Sao_Paulo
    command:
      - "--api.dashboard=true"
      - "--providers.docker=true"
      - "--providers.docker.exposedbydefault=false"
      - "--entrypoints.web.address=:80"
      - "--entrypoints.web.http.redirections.entryPoint.to=websecure"
      - "--entrypoints.web.http.redirections.entryPoint.scheme=https"
      - "--entrypoints.websecure.address=:443"
      - "--certificatesresolvers.letsencryptresolver.acme.httpchallenge=true"
      - "--certificatesresolvers.letsencryptresolver.acme.httpchallenge.entrypoint=web"
      - "--certificatesresolvers.letsencryptresolver.acme.storage=/letsencrypt/acme.json"
      - "--certificatesresolvers.letsencryptresolver.acme.email=${EMAIL_SSL}"
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - "/var/run/docker.sock:/var/run/docker.sock:ro"
      - "./letsencrypt:/letsencrypt"
      - "/etc/localtime:/etc/localtime:ro"
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.traefik.rule=Host(\`${URL_TRAEFIK}\`)"
      - "traefik.http.routers.traefik.entrypoints=websecure"
      - "traefik.http.routers.traefik.tls.certresolver=letsencryptresolver"
      - "traefik.http.routers.traefik.service=api@internal"
      - "traefik.http.routers.traefik.middlewares=auth"
      - "traefik.http.middlewares.auth.basicauth.users=${TRAEFIK_AUTH}"
    networks:
      - ${NOME_INSTANCIA}_network

  portainer:
    image: portainer/portainer-ce:latest
    container_name: ${NOME_INSTANCIA}_portainer
    restart: unless-stopped
    environment:
      - TZ=America/Sao_Paulo
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
      - portainer_data:/data
      - /etc/localtime:/etc/localtime:ro
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.portainer.rule=Host(\`${URL_PORTAINER}\`)"
      - "traefik.http.routers.portainer.entrypoints=websecure"
      - "traefik.http.routers.portainer.tls.certresolver=letsencryptresolver"
      - "traefik.http.services.portainer.loadbalancer.server.port=9000"
    networks:
      - ${NOME_INSTANCIA}_network

volumes:
  portainer_data:

networks:
  ${NOME_INSTANCIA}_network:
    external: true
EOF

## Cria MinIO
cat > docker-compose.minio.yml << EOF
version: '3.8'

services:
  minio:
    image: quay.io/minio/minio:latest
    container_name: ${NOME_INSTANCIA}_minio
    restart: unless-stopped
    command: server /data --console-address ":9001"
    environment:
      - TZ=America/Sao_Paulo
      - MINIO_ROOT_USER=${USER_MINIO}
      - MINIO_ROOT_PASSWORD=${PASS_MINIO}
      - MINIO_BROWSER_REDIRECT_URL=https://${URL_MINIO}
      - MINIO_SERVER_URL=https://${URL_S3}
    volumes:
      - minio_data:/data
      - /etc/localtime:/etc/localtime:ro
    labels:
      - "traefik.enable=true"
      # Console do MinIO (porta 9001)
      - "traefik.http.routers.minio-console.rule=Host(\`${URL_MINIO}\`)"
      - "traefik.http.routers.minio-console.entrypoints=websecure"
      - "traefik.http.routers.minio-console.tls.certresolver=letsencryptresolver"
      - "traefik.http.routers.minio-console.service=minio-console-svc"
      - "traefik.http.services.minio-console-svc.loadbalancer.server.port=9001"
      # API S3 (porta 9000)
      - "traefik.http.routers.minio-api.rule=Host(\`${URL_S3}\`)"
      - "traefik.http.routers.minio-api.entrypoints=websecure"
      - "traefik.http.routers.minio-api.tls.certresolver=letsencryptresolver"
      - "traefik.http.routers.minio-api.service=minio-api-svc"
      - "traefik.http.services.minio-api-svc.loadbalancer.server.port=9000"
    networks:
      - ${NOME_INSTANCIA}_network

volumes:
  minio_data:

networks:
  ${NOME_INSTANCIA}_network:
    external: true
EOF

## Cria Redis
cat > docker-compose.redis.yml << EOF
version: '3.8'

services:
  redis:
    image: redis:latest
    container_name: ${NOME_INSTANCIA}_redis
    restart: unless-stopped
    command: [
        "redis-server",
        "--appendonly",
        "yes",
        "--port",
        "6379"
      ]
    environment:
      - TZ=America/Sao_Paulo
    volumes:
      - redis_data:/data
      - /etc/localtime:/etc/localtime:ro
    networks:
      - ${NOME_INSTANCIA}_network
    #ports:
    #  - 6379:6379

volumes:
  redis_data:
    external: true
    name: ${NOME_INSTANCIA}_redis_data

networks:
  ${NOME_INSTANCIA}_network:
    external: true
    name: ${NOME_INSTANCIA}_network
EOF

## Cria PostgreSQL
cat > docker-compose.postgres.yml << EOF
version: '3.8'

services:
  postgres:
    image: postgres:14
    container_name: ${NOME_INSTANCIA}_postgres
    restart: unless-stopped
    command: >
      postgres
      -c max_connections=1000
      -c shared_buffers=1GB
      -c effective_cache_size=3GB
      -c maintenance_work_mem=256MB
      -c checkpoint_completion_target=0.9
      -c wal_buffers=16MB
      -c default_statistics_target=100
      -c random_page_cost=1.1
      -c effective_io_concurrency=200
      -c work_mem=32MB
      -c min_wal_size=1GB
      -c max_wal_size=4GB
      -c max_worker_processes=8
      -c max_parallel_workers_per_gather=4
      -c max_parallel_workers=8
      -c max_parallel_maintenance_workers=4
    environment:
      - POSTGRES_PASSWORD=${PASS_POSTGRES}
      - TZ=America/Sao_Paulo
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - /etc/localtime:/etc/localtime:ro
    networks:
      - ${NOME_INSTANCIA}_network
    #ports:
    #  - 5432:5432

volumes:
  postgres_data:
    external: true
    name: ${NOME_INSTANCIA}_postgres_data

networks:
  ${NOME_INSTANCIA}_network:
    external: true
    name: ${NOME_INSTANCIA}_network
EOF

## Cria RabbitMQ
cat > docker-compose.rabbitmq.yml << EOF
version: '3.8'

services:
  rabbitmq:
    image: rabbitmq:management
    container_name: ${NOME_INSTANCIA}_rabbitmq
    restart: unless-stopped
    command: rabbitmq-server
    hostname: rabbitmq
    environment:
      - TZ=America/Sao_Paulo
      - RABBITMQ_DEFAULT_USER=${USER_RABBITMQ}
      - RABBITMQ_DEFAULT_PASS=${PASS_RABBITMQ}
      - RABBITMQ_ERLANG_COOKIE=f9a807f6357ab93bcd653bbaa1d99dd3
      - RABBITMQ_DEFAULT_VHOST=/
    volumes:
      - rabbitmq_data:/var/lib/rabbitmq
      - /etc/localtime:/etc/localtime:ro
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.rabbitmq.rule=Host(\`${URL_RABBITMQ}\`)"
      - "traefik.http.routers.rabbitmq.entrypoints=websecure"
      - "traefik.http.routers.rabbitmq.tls.certresolver=letsencryptresolver"
      - "traefik.http.routers.rabbitmq.service=rabbitmq"
      - "traefik.http.services.rabbitmq.loadbalancer.server.port=15672"
    networks:
      - ${NOME_INSTANCIA}_network
    #ports:
    #  - 5672:5672
    #  - 15672:15672

volumes:
  rabbitmq_data:
    external: true
    name: ${NOME_INSTANCIA}_rabbitmq_data

networks:
  ${NOME_INSTANCIA}_network:
    external: true
    name: ${NOME_INSTANCIA}_network
EOF

## Cria N8N
cat > docker-compose.n8n.yml << EOF
version: '3.8'

services:
  n8n_editor:
    image: n8nio/n8n:latest
    container_name: ${NOME_INSTANCIA}_n8n_editor
    restart: unless-stopped
    command: start
    networks:
      - ${NOME_INSTANCIA}_network
    environment:
      - DB_TYPE=postgresdb
      - DB_POSTGRESDB_DATABASE=n8n_queue
      - DB_POSTGRESDB_HOST=postgres
      - DB_POSTGRESDB_PORT=5432
      - DB_POSTGRESDB_USER=postgres
      - DB_POSTGRESDB_PASSWORD=${PASS_POSTGRES}
      - N8N_ENCRYPTION_KEY=${N8N_ENCRYPTION_KEY}
      - N8N_HOST=${N8N_HOST}
      - N8N_EDITOR_BASE_URL=https://${N8N_HOST}/
      - WEBHOOK_URL=https://${N8N_WEBHOOK_HOST}/
      - N8N_PROTOCOL=https
      - NODE_ENV=production
      - EXECUTIONS_MODE=queue
      - EXECUTIONS_TIMEOUT=3600
      - EXECUTIONS_TIMEOUT_MAX=7200
      - OFFLOAD_MANUAL_EXECUTIONS_TO_WORKERS=true
      - N8N_RUNNERS_ENABLED=true
      - N8N_RUNNERS_MODE=internal
      - N8N_REINSTALL_MISSING_PACKAGES=true
      - N8N_COMMUNITY_PACKAGES_ENABLED=true
      - N8N_NODE_PATH=/home/node/.n8n/nodes
      - N8N_ENFORCE_SETTINGS_FILE_PERMISSIONS=true
      - QUEUE_BULL_REDIS_HOST=redis
      - QUEUE_BULL_REDIS_PORT=6379
      - QUEUE_BULL_REDIS_DB=2
      - N8N_METRICS=true
      - EXECUTIONS_DATA_PRUNE=true
      - EXECUTIONS_DATA_MAX_AGE=336
      - N8N_AI_ENABLED=false
      - N8N_AI_PROVIDER=openai
      - N8N_AI_OPENAI_API_KEY=
      - NODE_FUNCTION_ALLOW_BUILTIN=*
      - NODE_FUNCTION_ALLOW_EXTERNAL=moment,lodash
      - GENERIC_TIMEZONE=America/Sao_Paulo
      - TZ=America/Sao_Paulo
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.n8n_editor.rule=Host(\`${N8N_HOST}\`)"
      - "traefik.http.routers.n8n_editor.entrypoints=websecure"
      - "traefik.http.routers.n8n_editor.priority=1"
      - "traefik.http.routers.n8n_editor.tls.certresolver=letsencryptresolver"
      - "traefik.http.routers.n8n_editor.service=n8n_editor"
      - "traefik.http.services.n8n_editor.loadbalancer.server.port=5678"
      - "traefik.http.services.n8n_editor.loadbalancer.passHostHeader=1"

  n8n_webhook:
    image: n8nio/n8n:latest
    container_name: ${NOME_INSTANCIA}_n8n_webhook
    restart: unless-stopped
    command: webhook
    networks:
      - ${NOME_INSTANCIA}_network
    environment:
      - DB_TYPE=postgresdb
      - DB_POSTGRESDB_DATABASE=n8n_queue
      - DB_POSTGRESDB_HOST=postgres
      - DB_POSTGRESDB_PORT=5432
      - DB_POSTGRESDB_USER=postgres
      - DB_POSTGRESDB_PASSWORD=${PASS_POSTGRES}
      - N8N_ENCRYPTION_KEY=${N8N_ENCRYPTION_KEY}
      - N8N_HOST=${N8N_HOST}
      - N8N_EDITOR_BASE_URL=https://${N8N_HOST}/
      - WEBHOOK_URL=https://${N8N_WEBHOOK_HOST}/
      - N8N_PROTOCOL=https
      - NODE_ENV=production
      - EXECUTIONS_MODE=queue
      - EXECUTIONS_TIMEOUT=3600
      - EXECUTIONS_TIMEOUT_MAX=7200
      - OFFLOAD_MANUAL_EXECUTIONS_TO_WORKERS=true
      - N8N_RUNNERS_ENABLED=true
      - N8N_RUNNERS_MODE=internal
      - N8N_REINSTALL_MISSING_PACKAGES=true
      - N8N_COMMUNITY_PACKAGES_ENABLED=true
      - N8N_NODE_PATH=/home/node/.n8n/nodes
      - N8N_ENFORCE_SETTINGS_FILE_PERMISSIONS=true
      - QUEUE_BULL_REDIS_HOST=redis
      - QUEUE_BULL_REDIS_PORT=6379
      - QUEUE_BULL_REDIS_DB=2
      - N8N_METRICS=true
      - EXECUTIONS_DATA_PRUNE=true
      - EXECUTIONS_DATA_MAX_AGE=336
      - N8N_AI_ENABLED=false
      - N8N_AI_PROVIDER=openai
      - N8N_AI_OPENAI_API_KEY=
      - NODE_FUNCTION_ALLOW_BUILTIN=*
      - NODE_FUNCTION_ALLOW_EXTERNAL=moment,lodash
      - GENERIC_TIMEZONE=America/Sao_Paulo
      - TZ=America/Sao_Paulo
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.n8n_webhook.rule=Host(\`${N8N_WEBHOOK_HOST}\`)"
      - "traefik.http.routers.n8n_webhook.entrypoints=websecure"
      - "traefik.http.routers.n8n_webhook.priority=1"
      - "traefik.http.routers.n8n_webhook.tls.certresolver=letsencryptresolver"
      - "traefik.http.routers.n8n_webhook.service=n8n_webhook"
      - "traefik.http.services.n8n_webhook.loadbalancer.server.port=5678"
      - "traefik.http.services.n8n_webhook.loadbalancer.passHostHeader=1"

  n8n_worker:
    image: n8nio/n8n:latest
    container_name: ${NOME_INSTANCIA}_n8n_worker
    restart: unless-stopped
    command: worker --concurrency=10
    networks:
      - ${NOME_INSTANCIA}_network
    environment:
      - DB_TYPE=postgresdb
      - DB_POSTGRESDB_DATABASE=n8n_queue
      - DB_POSTGRESDB_HOST=postgres
      - DB_POSTGRESDB_PORT=5432
      - DB_POSTGRESDB_USER=postgres
      - DB_POSTGRESDB_PASSWORD=${PASS_POSTGRES}
      - N8N_ENCRYPTION_KEY=${N8N_ENCRYPTION_KEY}
      - N8N_HOST=${N8N_HOST}
      - N8N_EDITOR_BASE_URL=https://${N8N_HOST}/
      - WEBHOOK_URL=https://${N8N_WEBHOOK_HOST}/
      - N8N_PROTOCOL=https
      - NODE_ENV=production
      - EXECUTIONS_MODE=queue
      - EXECUTIONS_TIMEOUT=3600
      - EXECUTIONS_TIMEOUT_MAX=7200
      - OFFLOAD_MANUAL_EXECUTIONS_TO_WORKERS=true
      - N8N_RUNNERS_ENABLED=true
      - N8N_RUNNERS_MODE=internal
      - N8N_REINSTALL_MISSING_PACKAGES=true
      - N8N_COMMUNITY_PACKAGES_ENABLED=true
      - N8N_NODE_PATH=/home/node/.n8n/nodes
      - N8N_ENFORCE_SETTINGS_FILE_PERMISSIONS=true
      - QUEUE_BULL_REDIS_HOST=redis
      - QUEUE_BULL_REDIS_PORT=6379
      - QUEUE_BULL_REDIS_DB=2
      - N8N_METRICS=true
      - EXECUTIONS_DATA_PRUNE=true
      - EXECUTIONS_DATA_MAX_AGE=336
      - N8N_AI_ENABLED=false
      - N8N_AI_PROVIDER=openai
      - N8N_AI_OPENAI_API_KEY=
      - NODE_FUNCTION_ALLOW_BUILTIN=*
      - NODE_FUNCTION_ALLOW_EXTERNAL=moment,lodash
      - GENERIC_TIMEZONE=America/Sao_Paulo
      - TZ=America/Sao_Paulo

networks:
  ${NOME_INSTANCIA}_network:
    external: true
    name: ${NOME_INSTANCIA}_network
EOF

## Gera senha para o usu√°rio FAQ
PASS_FAQ_USER=$(gerar_senha 16)
USER_FAQ="faq_user"

## Define URL FAQ
URL_FAQ="faq.${NOME_INSTANCIA}.${DOMINIO_BASE}"

## Cria FAQ System
cat > docker-compose.faq.yml << EOF
version: '3.8'

services:
  faq-system:
    image: ghcr.io/gmowses/faq:v1
    container_name: ${NOME_INSTANCIA}_faq_system
    restart: unless-stopped
    
    environment:
      # Banco de dados PostgreSQL
      - DB_HOST=postgres
      - DB_PORT=5432
      - DB_NAME=chatdigi
      - DB_USER=${USER_FAQ}
      - DB_PASSWORD=${PASS_FAQ_USER}
      
      # JWT
      - JWT_SECRET=${N8N_ENCRYPTION_KEY}
      
      # URLs
      - FRONTEND_URL=https://${URL_FAQ}
      - SYNC_WEBHOOK_URL=https://${N8N_WEBHOOK_HOST}/webhook/sync-rag
      
      # Configura√ß√µes da aplica√ß√£o
      - NODE_ENV=production
      - PORT=3001
      - TZ=America/Sao_Paulo

    volumes:
      - faq_logs:/app/logs

    networks:
      - ${NOME_INSTANCIA}_network

    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.faq_system.rule=Host(\`${URL_FAQ}\`)"
      - "traefik.http.routers.faq_system.entrypoints=websecure"
      - "traefik.http.routers.faq_system.tls.certresolver=letsencryptresolver"
      - "traefik.http.services.faq_system.loadbalancer.server.port=3001"

volumes:
  faq_logs:
    external: true
    name: ${NOME_INSTANCIA}_faq_logs

networks:
  ${NOME_INSTANCIA}_network:
    external: true
    name: ${NOME_INSTANCIA}_network
EOF

## Cria ChatDigi System
cat > docker-compose.chatdigi.yml << EOF
version: '3.8'

services:
  chatdigi-backend:
    image: ghcr.io/gmowses/chatdigi-backend:v1
    container_name: ${NOME_INSTANCIA}_chatdigi_backend
    restart: unless-stopped
    
    environment:
      # Whisper API
      - WHISPER_URL=http://whisper-api:9000
      
      # Banco de dados
      - DB_DIALECT=postgres
      - DB_HOST=postgres
      - DB_PORT=5432
      - DB_NAME=chatdigi
      - DB_USER=${USER_FAQ}
      - DB_PASS=${PASS_FAQ_USER}
      - DB_TIMEZONE=America/Sao_Paulo
      - DB_LOGGING=false
      - DB_POOL_MAX=${DB_POOL_MAX:-100}
      - DB_POOL_MIN=${DB_POOL_MIN:-15}
      - DB_POOL_ACQUIRE=${DB_POOL_ACQUIRE:-30000}
      - DB_POOL_IDLE=${DB_POOL_IDLE:-600000}
      
      # Redis
      - REDIS_HOST=redis
      - REDIS_PORT=6379
      - REDIS_PASSWORD=
      - REDIS_SECRET_KEY=${REDIS_SECRET_KEY:-MULTI100}
      - REDIS_URI=redis://redis:6379
      - REDIS_URI_ACK=redis://redis:6379
      - REDIS_URI_MSG_CONN=redis://redis:6379
      - REDIS_OPT_LIMITER_MAX=${REDIS_OPT_LIMITER_MAX:-1}
      - REDIS_OPT_LIMITER_DURATION=${REDIS_OPT_LIMITER_DURATION:-3000}
      
      # JWT
      - JWT_SECRET=${PASS_CHATDIGI_JWT}
      - JWT_REFRESH_SECRET=${PASS_CHATDIGI_REFRESH}
      
      # URLs
      - FRONTEND_URL=https://${URL_CHATDIGI_FRONTEND}
      - BACKEND_URL=https://${URL_CHATDIGI_BACKEND}
      
      # Configura√ß√µes da aplica√ß√£o
      - NODE_ENV=production
      - PORT=8080
      - MAX_FILE_SIZE=${MAX_FILE_SIZE:-50}
      - WHATSAPP_TIMEOUT=${WHATSAPP_TIMEOUT:-30000}
      - TZ=America/Sao_Paulo
      
      # Integra√ß√µes
      - OPENAI_API_KEY=${OPENAI_API_KEY:-}
      - GERENCIANET_CLIENT_ID=${GERENCIANET_CLIENT_ID:-}
      - GERENCIANET_CLIENT_SECRET=${GERENCIANET_CLIENT_SECRET:-}
      - GERENCIANET_SANDBOX=${GERENCIANET_SANDBOX:-true}
      - GERENCIANET_PIX_CERT=${GERENCIANET_PIX_CERT:-certificadoEfi}
      
      # Sentry (opcional)
      - SENTRY_DSN=${SENTRY_DSN:-}
      
      # S3 / MinIO (enabled for MinIO storage)
      - S3_STORAGE=DISABLE
      - S3_PROVIDER=minio
      - S3_ACCESS_KEY=chatdigiuser
      - S3_SECRET_KEY=supersecretpassword
      - S3_ENDPOINT=s3.digi.gmowses.cloud
      - S3_PORT=443
      - S3_REGION=us-east-1
      - S3_USE_SSL=true
      - S3_BUCKET=chatdigi-files

    volumes:
      - chatdigi_backend_uploads:/app/public
      - chatdigi_backend_logs:/app/logs

    networks:
      - ${NOME_INSTANCIA}_network

    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.chatdigi_backend_api.rule=Host(\`${URL_CHATDIGI_BACKEND}\`)"
      - "traefik.http.routers.chatdigi_backend_api.entrypoints=websecure"
      - "traefik.http.routers.chatdigi_backend_api.tls.certresolver=letsencryptresolver"
      - "traefik.http.services.chatdigi_backend_api.loadbalancer.server.port=8080"
      - "traefik.http.services.chatdigi_backend_api.loadbalancer.passHostHeader=true"
      - "traefik.http.routers.chatdigi_backend_api.service=chatdigi_backend_api"
      - "traefik.http.routers.chatdigi_backend_socketio.rule=Host(\`${URL_CHATDIGI_BACKEND}\`)"
      - "traefik.http.routers.chatdigi_backend_socketio.entrypoints=websecure"
      - "traefik.http.routers.chatdigi_backend_socketio.tls.certresolver=letsencryptresolver"
      - "traefik.http.services.chatdigi_backend_socketio.loadbalancer.server.port=8080"
      - "traefik.http.services.chatdigi_backend_socketio.loadbalancer.passHostHeader=true"
      - "traefik.http.routers.chatdigi_backend_socketio.service=chatdigi_backend_socketio"

  chatdigi-frontend:
    image: ghcr.io/gmowses/chatdigi-frontend:v1
    container_name: ${NOME_INSTANCIA}_chatdigi_frontend
    restart: unless-stopped
    
    environment:
      - TZ=America/Sao_Paulo
      - REACT_APP_BACKEND_URL=https://${URL_CHATDIGI_BACKEND}
      - REACT_APP_FRONTEND_URL=https://${URL_CHATDIGI_FRONTEND}
      - REACT_APP_PRIMARY_COLOR=${REACT_APP_PRIMARY_COLOR:-#FF7A00}
      - REACT_APP_SUPPORT_NUMBER=${REACT_APP_SUPPORT_NUMBER:-+55 11 99999-9999}

    networks:
      - ${NOME_INSTANCIA}_network

    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.chatdigi_frontend.rule=Host(\`${URL_CHATDIGI_FRONTEND}\`)"
      - "traefik.http.routers.chatdigi_frontend.entrypoints=websecure"
      - "traefik.http.routers.chatdigi_frontend.tls.certresolver=letsencryptresolver"
      - "traefik.http.services.chatdigi_frontend.loadbalancer.server.port=80"
      - "traefik.http.services.chatdigi_frontend.loadbalancer.passHostHeader=true"
      - "traefik.http.routers.chatdigi_frontend.service=chatdigi_frontend"

  qr-generator:
    image: mowses1997/qr-generator:latest
    container_name: ${NOME_INSTANCIA}_qr_generator
    restart: unless-stopped
    
    environment:
      - FLASK_ENV=production
      - FLASK_APP=app.py
      - TZ=America/Sao_Paulo

    networks:
      - ${NOME_INSTANCIA}_network

  whisper-api:
    image: mowses1997/whisper-api:latest
    container_name: ${NOME_INSTANCIA}_whisper_api
    restart: unless-stopped
    
    networks:
      - ${NOME_INSTANCIA}_network

volumes:
  chatdigi_backend_uploads:
    external: true
    name: ${NOME_INSTANCIA}_chatdigi_backend_uploads
  
  chatdigi_backend_logs:
    external: true
    name: ${NOME_INSTANCIA}_chatdigi_backend_logs

networks:
  ${NOME_INSTANCIA}_network:
    external: true
    name: ${NOME_INSTANCIA}_network
EOF

msg "$VERDE" "‚úÖ Arquivos docker-compose criados"



## ===================================================================================================
##                                    INICIANDO CONTAINERS
## ===================================================================================================

msg "$AMARELO" ""
msg "$AMARELO" "=== INICIANDO TODOS OS SERVI√áOS ==="
echo ""

## Cria diret√≥rio para certificados
mkdir -p letsencrypt

## Verifica se Docker est√° funcionando antes de iniciar containers
if ! verificar_docker; then
    msg "$VERMELHO" "‚ùå Docker n√£o est√° funcionando corretamente"
    diagnosticar_docker
    exit 1
fi

## Cria rede compartilhada se n√£o existir
msg "$BRANCO" "üåê Verificando rede compartilhada..."
if docker network ls --format '{{.Name}}' | grep -q "^${NOME_INSTANCIA}_network$"; then
    msg "$VERDE" "‚úÖ Rede ${NOME_INSTANCIA}_network j√° existe"
    log_message "Rede ${NOME_INSTANCIA}_network j√° existia"
else
    if exec_log "docker network create --driver bridge ${NOME_INSTANCIA}_network" "Criando rede compartilhada"; then
        msg "$VERDE" "‚úÖ Rede compartilhada criada"
        log_message "Rede compartilhada criada com sucesso"
    else
        msg "$VERMELHO" "‚ùå Erro ao criar rede"
        log_message "ERRO: Falha ao criar rede compartilhada"
        exit 1
    fi
fi

## Inicia todos os servi√ßos
msg "$BRANCO" "üöÄ Iniciando Traefik, Portainer e MinIO..."

# Inicia Traefik + Portainer juntos
msg "$AMARELO" "üì° Iniciando Traefik e Portainer..."
if exec_log "docker compose -f docker-compose.traefik-portainer.yml up -d" "Deploy do Traefik e Portainer"; then
    msg "$VERDE" "‚úÖ Traefik e Portainer iniciados"
    log_message "Traefik e Portainer iniciados com sucesso"
else
    msg "$VERMELHO" "‚ùå Erro ao iniciar Traefik e Portainer"
    log_message "ERRO: Falha ao iniciar Traefik e Portainer"
    exit 1
fi

# Aguarda Traefik e Portainer ficarem prontos
sleep 10

# Cria volume Redis
msg "$AMARELO" "üíæ Criando volume Redis..."
if exec_log "docker volume create ${NOME_INSTANCIA}_redis_data" "Criando volume Redis"; then
    msg "$VERDE" "‚úÖ Volume Redis criado"
    log_message "Volume Redis criado com sucesso"
else
    msg "$VERMELHO" "‚ùå Erro ao criar volume Redis"
    log_message "ERRO: Falha ao criar volume Redis"
    exit 1
fi

# Inicia MinIO
msg "$AMARELO" "üíæ Iniciando MinIO..."
if exec_log "docker compose -f docker-compose.minio.yml up -d" "Deploy do MinIO"; then
    msg "$VERDE" "‚úÖ MinIO iniciado"
    log_message "MinIO iniciado com sucesso"
else
    msg "$VERMELHO" "‚ùå Erro ao iniciar MinIO"
    log_message "ERRO: Falha ao iniciar MinIO"
    exit 1
fi

# Inicia Redis
msg "$AMARELO" "üî¥ Iniciando Redis..."
if exec_log "docker compose -f docker-compose.redis.yml up -d" "Deploy do Redis"; then
    msg "$VERDE" "‚úÖ Redis iniciado"
    log_message "Redis iniciado com sucesso"
else
    msg "$VERMELHO" "‚ùå Erro ao iniciar Redis"
    log_message "ERRO: Falha ao iniciar Redis"
    exit 1
fi

# Cria volume PostgreSQL
msg "$AMARELO" "üíæ Criando volume PostgreSQL..."
if exec_log "docker volume create ${NOME_INSTANCIA}_postgres_data" "Criando volume PostgreSQL"; then
    msg "$VERDE" "‚úÖ Volume PostgreSQL criado"
else
    msg "$VERMELHO" "‚ùå Erro ao criar volume PostgreSQL"
    log_message "ERRO: Falha ao criar volume PostgreSQL"
    exit 1
fi

# Cria volume RabbitMQ
msg "$AMARELO" "üì¶ Criando volume RabbitMQ..."
if exec_log "docker volume create ${NOME_INSTANCIA}_rabbitmq_data" "Criando volume RabbitMQ"; then
    msg "$VERDE" "‚úÖ Volume RabbitMQ criado"
    log_message "Volume RabbitMQ criado com sucesso"
else
    msg "$VERMELHO" "‚ùå Erro ao criar volume RabbitMQ"
    log_message "ERRO: Falha ao criar volume RabbitMQ"
    exit 1
fi

# Inicia PostgreSQL
msg "$AMARELO" "üî¥ Iniciando PostgreSQL..."
if exec_log "docker compose -f docker-compose.postgres.yml up -d" "Deploy do PostgreSQL"; then
    msg "$VERDE" "‚úÖ PostgreSQL iniciado"
    log_message "PostgreSQL iniciado com sucesso"
else
    msg "$VERMELHO" "‚ùå Erro ao iniciar PostgreSQL"
    log_message "ERRO: Falha ao iniciar PostgreSQL"
    exit 1
fi

# Aguarda PostgreSQL ficar pronto
msg "$AMARELO" "‚è≥ Aguardando PostgreSQL ficar pronto..."
sleep 15

# Cria banco de dados N8N no PostgreSQL
msg "$AMARELO" "üóÑÔ∏è Criando banco de dados N8N..."
if exec_log "docker exec ${NOME_INSTANCIA}_postgres psql -U postgres -c 'CREATE DATABASE n8n_queue;'" "Criando banco de dados N8N"; then
    msg "$VERDE" "‚úÖ Banco de dados N8N criado"
    log_message "Banco de dados N8N criado com sucesso"
else
    msg "$AMARELO" "‚ö†Ô∏è Banco de dados N8N j√° existe ou erro na cria√ß√£o"
    log_message "Banco de dados N8N j√° existia ou erro na cria√ß√£o"
fi

# Cria banco de dados ChatDigi no PostgreSQL
msg "$AMARELO" "üóÑÔ∏è Criando banco de dados ChatDigi..."
if exec_log "docker exec ${NOME_INSTANCIA}_postgres psql -U postgres -c 'CREATE DATABASE chatdigi;'" "Criando banco de dados ChatDigi"; then
    msg "$VERDE" "‚úÖ Banco de dados ChatDigi criado"
    log_message "Banco de dados ChatDigi criado com sucesso"
else
    msg "$AMARELO" "‚ö†Ô∏è Banco de dados ChatDigi j√° existe ou erro na cria√ß√£o"
    log_message "Banco de dados ChatDigi j√° existia ou erro na cria√ß√£o"
fi

# Cria usu√°rio espec√≠fico para o FAQ
msg "$AMARELO" "üë§ Criando usu√°rio FAQ..."
CREATE_USER_SQL="CREATE USER ${USER_FAQ} WITH PASSWORD '${PASS_FAQ_USER}';"
if exec_log "docker exec ${NOME_INSTANCIA}_postgres psql -U postgres -c \"${CREATE_USER_SQL}\"" "Criando usu√°rio FAQ"; then
    msg "$VERDE" "‚úÖ Usu√°rio FAQ criado"
    log_message "Usu√°rio FAQ criado com sucesso"
else
    msg "$AMARELO" "‚ö†Ô∏è Usu√°rio FAQ j√° existe ou erro na cria√ß√£o"
    log_message "Usu√°rio FAQ j√° existia ou erro na cria√ß√£o"
fi

# D√° permiss√µes totais ao usu√°rio FAQ
msg "$AMARELO" "üîë Configurando permiss√µes do usu√°rio FAQ..."
GRANT_PERMISSIONS_SQL="GRANT ALL PRIVILEGES ON DATABASE chatdigi TO ${USER_FAQ};"
if exec_log "docker exec ${NOME_INSTANCIA}_postgres psql -U postgres -c \"${GRANT_PERMISSIONS_SQL}\"" "Configurando permiss√µes"; then
    msg "$VERDE" "‚úÖ Permiss√µes configuradas"
    log_message "Permiss√µes do usu√°rio FAQ configuradas com sucesso"
else
    msg "$AMARELO" "‚ö†Ô∏è Erro ao configurar permiss√µes"
    log_message "Erro ao configurar permiss√µes do usu√°rio FAQ"
fi

# Cria script SQL tempor√°rio para as tabelas
msg "$AMARELO" "üìù Criando estrutura das tabelas FAQ..."
cat > /tmp/chatdigi_schema.sql << 'EOSQL'
-- Script de estrutura para o sistema FAQ (sem dados de exemplo)
-- Assume que a tabela Users j√° existe

-- Criar extens√£o vector para embeddings
CREATE EXTENSION IF NOT EXISTS vector;

-- Criar tabela documents para RAG/embeddings
CREATE TABLE IF NOT EXISTS documents (
    id BIGSERIAL PRIMARY KEY,
    content TEXT,
    metadata JSONB,
    embedding vector(1536),
    titulo TEXT
);

-- Criar tabela categoria
CREATE TABLE categoria (
    id SERIAL PRIMARY KEY,
    nome VARCHAR(255) NOT NULL UNIQUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Criar tabela sub_categoria
CREATE TABLE sub_categoria (
    id SERIAL PRIMARY KEY,
    nome VARCHAR(255) NOT NULL,
    categoria_id INTEGER NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (categoria_id) REFERENCES categoria(id) ON DELETE CASCADE,
    UNIQUE(nome, categoria_id)
);

-- Criar tabela faq
CREATE TABLE faq (
    id SERIAL PRIMARY KEY,
    pergunta TEXT NOT NULL,
    resposta TEXT NOT NULL,
    categoria_id INTEGER NOT NULL,
    sub_categoria_id INTEGER,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (categoria_id) REFERENCES categoria(id) ON DELETE CASCADE,
    FOREIGN KEY (sub_categoria_id) REFERENCES sub_categoria(id) ON DELETE SET NULL
);

-- √çndices para performance
CREATE INDEX idx_faq_categoria ON faq(categoria_id);
CREATE INDEX idx_faq_sub_categoria ON faq(sub_categoria_id);
CREATE INDEX idx_sub_categoria_categoria ON sub_categoria(categoria_id);

-- √çndice de texto completo para busca
CREATE INDEX idx_faq_search ON faq USING gin(to_tsvector('portuguese', pergunta || ' ' || resposta));

-- Fun√ß√£o para atualizar updated_at
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ language 'plpgsql';

-- Trigger para atualizar updated_at na tabela faq
CREATE TRIGGER update_faq_updated_at 
    BEFORE UPDATE ON faq 
    FOR EACH ROW 
    EXECUTE FUNCTION update_updated_at_column();

-- Fun√ß√£o para busca sem√¢ntica com embeddings
CREATE OR REPLACE FUNCTION match_documents (
  query_embedding vector(1536),
  match_count int DEFAULT NULL,
  filter jsonb DEFAULT '{}'
)
RETURNS TABLE (
  id bigint,
  content text,
  metadata jsonb,
  similarity float
)
LANGUAGE plpgsql
AS $function$
#variable_conflict use_column
BEGIN
  RETURN QUERY
  SELECT
    id,
    content,
    metadata,
    1 - (documents.embedding <=> query_embedding) AS similarity
  FROM documents
  WHERE metadata @> filter
  ORDER BY documents.embedding <=> query_embedding
  LIMIT match_count;
END;
$function$;

-- Grants para usu√°rios (ajustar conforme necess√°rio)
GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO postgres;
GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA public TO postgres;
EOSQL

# Executa o script SQL no banco chatdigi
if exec_log "docker exec -i ${NOME_INSTANCIA}_postgres psql -U postgres -d chatdigi < /tmp/chatdigi_schema.sql" "Criando tabelas FAQ"; then
    msg "$VERDE" "‚úÖ Tabelas FAQ criadas com sucesso"
    log_message "Tabelas FAQ criadas com sucesso"
else
    msg "$AMARELO" "‚ö†Ô∏è Erro ao criar tabelas FAQ ou j√° existem"
    log_message "Erro ao criar tabelas FAQ ou j√° existem"
fi

# Configura permiss√µes espec√≠ficas nas tabelas para o usu√°rio FAQ
msg "$AMARELO" "üîê Configurando permiss√µes espec√≠ficas nas tabelas..."
GRANT_TABLE_PERMISSIONS_SQL="
GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO ${USER_FAQ};
GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA public TO ${USER_FAQ};
ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL ON TABLES TO ${USER_FAQ};
ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL ON SEQUENCES TO ${USER_FAQ};
"
if exec_log "docker exec ${NOME_INSTANCIA}_postgres psql -U postgres -d chatdigi -c \"${GRANT_TABLE_PERMISSIONS_SQL}\"" "Configurando permiss√µes espec√≠ficas"; then
    msg "$VERDE" "‚úÖ Permiss√µes espec√≠ficas configuradas"
    log_message "Permiss√µes espec√≠ficas nas tabelas configuradas com sucesso"
else
    msg "$AMARELO" "‚ö†Ô∏è Erro ao configurar permiss√µes espec√≠ficas"
    log_message "Erro ao configurar permiss√µes espec√≠ficas nas tabelas"
fi

# Remove arquivo tempor√°rio
rm -f /tmp/chatdigi_schema.sql

# Inicia RabbitMQ
msg "$AMARELO" "üê∞ Iniciando RabbitMQ..."
if exec_log "docker compose -f docker-compose.rabbitmq.yml up -d" "Deploy do RabbitMQ"; then
    msg "$VERDE" "‚úÖ RabbitMQ iniciado"
    log_message "RabbitMQ iniciado com sucesso"
else
    msg "$VERMELHO" "‚ùå Erro ao iniciar RabbitMQ"
    log_message "ERRO: Falha ao iniciar RabbitMQ"
    exit 1
fi

# Inicia N8N
msg "$AMARELO" "ü§ñ Iniciando N8N..."
if exec_log "docker compose -f docker-compose.n8n.yml up -d" "Deploy do N8N"; then
    msg "$VERDE" "‚úÖ N8N iniciado"
    log_message "N8N iniciado com sucesso"
else
    msg "$VERMELHO" "‚ùå Erro ao iniciar N8N"
    log_message "ERRO: Falha ao iniciar N8N"
    exit 1
fi

# Cria volume FAQ logs
msg "$AMARELO" "üìù Criando volume FAQ logs..."
if exec_log "docker volume create ${NOME_INSTANCIA}_faq_logs" "Criando volume FAQ logs"; then
    msg "$VERDE" "‚úÖ Volume FAQ logs criado"
    log_message "Volume FAQ logs criado com sucesso"
else
    msg "$VERMELHO" "‚ùå Erro ao criar volume FAQ logs"
    log_message "ERRO: Falha ao criar volume FAQ logs"
    exit 1
fi

# Cria volumes ChatDigi
msg "$AMARELO" "üí¨ Criando volumes ChatDigi..."
if exec_log "docker volume create ${NOME_INSTANCIA}_chatdigi_backend_uploads" "Criando volume ChatDigi uploads"; then
    msg "$VERDE" "‚úÖ Volume ChatDigi uploads criado"
    log_message "Volume ChatDigi uploads criado com sucesso"
else
    msg "$VERMELHO" "‚ùå Erro ao criar volume ChatDigi uploads"
    log_message "ERRO: Falha ao criar volume ChatDigi uploads"
    exit 1
fi

if exec_log "docker volume create ${NOME_INSTANCIA}_chatdigi_backend_logs" "Criando volume ChatDigi logs"; then
    msg "$VERDE" "‚úÖ Volume ChatDigi logs criado"
    log_message "Volume ChatDigi logs criado com sucesso"
else
    msg "$VERMELHO" "‚ùå Erro ao criar volume ChatDigi logs"
    log_message "ERRO: Falha ao criar volume ChatDigi logs"
    exit 1
fi

# Inicia FAQ System
msg "$AMARELO" "‚ùì Iniciando Sistema FAQ..."
if exec_log "docker compose -f docker-compose.faq.yml up -d" "Deploy do FAQ System"; then
    msg "$VERDE" "‚úÖ Sistema FAQ iniciado"
    log_message "Sistema FAQ iniciado com sucesso"
else
    msg "$VERMELHO" "‚ùå Erro ao iniciar Sistema FAQ"
    log_message "ERRO: Falha ao iniciar Sistema FAQ"
    exit 1
fi

# Inicia ChatDigi System
msg "$AMARELO" "üí¨ Iniciando ChatDigi System..."
if exec_log "docker compose -f docker-compose.chatdigi.yml up -d" "Deploy do ChatDigi System"; then
    msg "$VERDE" "‚úÖ ChatDigi System iniciado"
    log_message "ChatDigi System iniciado com sucesso"
else
    msg "$VERMELHO" "‚ùå Erro ao iniciar ChatDigi System"
    log_message "ERRO: Falha ao iniciar ChatDigi System"
    exit 1
fi

msg "$VERDE" "‚úÖ Todos os servi√ßos iniciados com sucesso"

## Aguarda containers ficarem prontos
log_message "Aguardando containers ficarem prontos..."
aguardar_container "${NOME_INSTANCIA}_traefik"
aguardar_container "${NOME_INSTANCIA}_portainer"
aguardar_container "${NOME_INSTANCIA}_minio"
aguardar_container "${NOME_INSTANCIA}_redis"
aguardar_container "${NOME_INSTANCIA}_postgres"
aguardar_container "${NOME_INSTANCIA}_rabbitmq"
aguardar_container "${NOME_INSTANCIA}_n8n_editor"
aguardar_container "${NOME_INSTANCIA}_n8n_webhook"
aguardar_container "${NOME_INSTANCIA}_n8n_worker"
aguardar_container "${NOME_INSTANCIA}_faq_system"
aguardar_container "${NOME_INSTANCIA}_chatdigi_backend"
aguardar_container "${NOME_INSTANCIA}_chatdigi_frontend"
aguardar_container "${NOME_INSTANCIA}_qr_generator"

## ===================================================================================================
##                                    CONFIGURA√á√ÉO DO PORTAINER
## ===================================================================================================

msg "$AMARELO" ""
msg "$AMARELO" "=== CONFIGURANDO PORTAINER ==="
echo ""

sleep 20
msg "$BRANCO" "üë§ Configurando conta do Portainer..."
log_message "Configurando conta do Portainer via API"

CURL_CMD="curl -k -s -X POST \"https://$URL_PORTAINER/api/users/admin/init\" -H \"Content-Type: application/json\" -d \"{\\\"Username\\\": \\\"$USER_PORTAINER\\\", \\\"Password\\\": \\\"$PASS_PORTAINER\\\"}\""
log_message "Executando: $CURL_CMD"

RESPONSE=$(curl -k -s -X POST "https://$URL_PORTAINER/api/users/admin/init" \
    -H "Content-Type: application/json" \
    -d "{\"Username\": \"$USER_PORTAINER\", \"Password\": \"$PASS_PORTAINER\"}")

log_message "Resposta da API do Portainer: $RESPONSE"

if echo "$RESPONSE" | grep -q "\"Username\":\"$USER_PORTAINER\""; then
    msg "$VERDE" "‚úÖ Conta do Portainer criada com sucesso!"
    log_message "Conta do Portainer criada com sucesso"
elif echo "$RESPONSE" | grep -q "\"message\":\"User already exists\""; then
    msg "$VERDE" "‚úÖ Conta do Portainer j√° existe!"
    log_message "Conta do Portainer j√° existia"
elif echo "$RESPONSE" | grep -q "\"Id\".*\"Username\""; then
    msg "$VERDE" "‚úÖ Conta do Portainer configurada!"
    log_message "Conta do Portainer configurada com sucesso"
else
    msg "$AMARELO" "‚ö†Ô∏è  N√£o foi poss√≠vel criar a conta automaticamente"
    msg "$AMARELO" "‚ÑπÔ∏è  Acesse o Portainer em at√© 5 minutos para criar a conta!"
    log_message "AVISO: N√£o foi poss√≠vel criar conta do Portainer automaticamente"
fi

## ===================================================================================================
##                                      SALVANDO CONFIGURA√á√ïES
## ===================================================================================================

## Salva informa√ß√µes em arquivo
cat > credenciais.txt << EOF
===================================================
         CREDENCIAIS E INFORMA√á√ïES DE ACESSO
              NEUROBOOST DIGITAL
===================================================

Vers√£o do Script: $VERSION
Data da Instala√ß√£o: $(date)
Nome da Inst√¢ncia: $NOME_INSTANCIA
Diret√≥rio do Projeto: $PROJETO_DIR

===================================================
                 URLs DE ACESSO
===================================================

Traefik Dashboard: https://$URL_TRAEFIK
Portainer: https://$URL_PORTAINER
MinIO Console: https://$URL_MINIO
MinIO S3 API: https://$URL_S3
RabbitMQ Management: https://$URL_RABBITMQ
N8N Editor: https://$N8N_HOST
N8N Webhook: https://$N8N_WEBHOOK_HOST
FAQ System: https://$URL_FAQ
ChatDigi Frontend: https://$URL_CHATDIGI_FRONTEND
ChatDigi Backend: https://$URL_CHATDIGI_BACKEND

===================================================
                  CREDENCIAIS
===================================================

TRAEFIK DASHBOARD:
  URL: https://$URL_TRAEFIK
  Usu√°rio: $USER_TRAEFIK
  Senha: $PASS_TRAEFIK

PORTAINER:
  URL: https://$URL_PORTAINER
  Usu√°rio: $USER_PORTAINER
  Senha: $PASS_PORTAINER

MINIO:
  URL: https://$URL_MINIO
  Usu√°rio: $USER_MINIO
  Senha: $PASS_MINIO

POSTGRESQL:
  Host: localhost
  Porta: 5432
  Usu√°rio: postgres
  Senha: $PASS_POSTGRES
  Banco N8N: n8n_queue
  Banco ChatDigi: chatdigi
  Usu√°rio FAQ: $USER_FAQ
  Senha FAQ: $PASS_FAQ_USER

RABBITMQ:
  URL: https://$URL_RABBITMQ
  Usu√°rio: $USER_RABBITMQ
  Senha: $PASS_RABBITMQ
  Host: rabbitmq
  Porta AMQP: 5672
  Porta Management: 15672

N8N:
  Editor: https://$N8N_HOST
  Webhook: https://$N8N_WEBHOOK_HOST
  Chave de Criptografia: $N8N_ENCRYPTION_KEY

FAQ SYSTEM:
  URL: https://$URL_FAQ
  Banco: chatdigi
  Usu√°rio BD: $USER_FAQ
  Senha BD: $PASS_FAQ_USER
  JWT Secret: $N8N_ENCRYPTION_KEY
  Webhook Sync: https://$N8N_WEBHOOK_HOST/webhook/sync-rag

CHATDIGI SYSTEM:
  Frontend: https://$URL_CHATDIGI_FRONTEND
  Backend API: https://$URL_CHATDIGI_BACKEND
  Banco: chatdigi
  Usu√°rio BD: $USER_FAQ
  Senha BD: $PASS_FAQ_USER
  JWT Secret: $PASS_CHATDIGI_JWT
  JWT Refresh Secret: $PASS_CHATDIGI_REFRESH
  Redis: redis://redis:6379 (sem senha)

===================================================
                COMANDOS √öTEIS
===================================================

Entrar no diret√≥rio:
  cd $PROJETO_DIR

Ver status dos containers:
  docker ps

Ver logs Traefik:
  docker compose -f docker-compose.traefik-portainer.yml logs -f traefik

Ver logs Portainer:
  docker compose -f docker-compose.traefik-portainer.yml logs -f portainer

Ver logs MinIO:
  docker compose -f docker-compose.minio.yml logs -f

Ver logs Redis:
  docker compose -f docker-compose.redis.yml logs -f

Ver logs PostgreSQL:
  docker compose -f docker-compose.postgres.yml logs -f

Ver logs RabbitMQ:
  docker compose -f docker-compose.rabbitmq.yml logs -f

Ver logs N8N:
  docker compose -f docker-compose.n8n.yml logs -f

Ver logs FAQ System:
  docker compose -f docker-compose.faq.yml logs -f

Ver logs ChatDigi:
  docker compose -f docker-compose.chatdigi.yml logs -f

Parar todos os servi√ßos:
  docker compose -f docker-compose.traefik-portainer.yml down
  docker compose -f docker-compose.minio.yml down
  docker compose -f docker-compose.redis.yml down
  docker compose -f docker-compose.postgres.yml down
  docker compose -f docker-compose.rabbitmq.yml down
  docker compose -f docker-compose.n8n.yml down
docker compose -f docker-compose.faq.yml down
docker compose -f docker-compose.chatdigi.yml down

Reiniciar Traefik:
  docker compose -f docker-compose.traefik-portainer.yml restart traefik

Reiniciar Portainer:
  docker compose -f docker-compose.traefik-portainer.yml restart portainer

Reiniciar MinIO:
  docker compose -f docker-compose.minio.yml restart

Reiniciar Redis:
  docker compose -f docker-compose.redis.yml restart

Reiniciar PostgreSQL:
  docker compose -f docker-compose.postgres.yml restart

Reiniciar RabbitMQ:
  docker compose -f docker-compose.rabbitmq.yml restart

Reiniciar N8N:
  docker compose -f docker-compose.n8n.yml restart

Reiniciar FAQ System:
  docker compose -f docker-compose.faq.yml restart

Reiniciar ChatDigi:
  docker compose -f docker-compose.chatdigi.yml restart

Atualizar imagens:
  docker compose -f docker-compose.traefik-portainer.yml pull && docker compose -f docker-compose.traefik-portainer.yml up -d
  docker compose -f docker-compose.minio.yml pull && docker compose -f docker-compose.minio.yml up -d
  docker compose -f docker-compose.redis.yml pull && docker compose -f docker-compose.redis.yml up -d
  docker compose -f docker-compose.postgres.yml pull && docker compose -f docker-compose.postgres.yml up -d
  docker compose -f docker-compose.rabbitmq.yml pull && docker compose -f docker-compose.rabbitmq.yml up -d
  docker compose -f docker-compose.n8n.yml pull && docker compose -f docker-compose.n8n.yml up -d
docker compose -f docker-compose.faq.yml pull && docker compose -f docker-compose.faq.yml up -d
docker compose -f docker-compose.chatdigi.yml pull && docker compose -f docker-compose.chatdigi.yml up -d

===================================================
EOF

## Credenciais salvas apenas na pasta do cliente
log_message "Credenciais salvas em: $PROJETO_DIR/credenciais.txt"

## ===================================================================================================
##                                          FINALIZA√á√ÉO
## ===================================================================================================

clear
msg "$VERDE" "
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë           ‚úÖ INSTALA√á√ÉO CONCLU√çDA COM SUCESSO!                 ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
"

msg "$AMARELO" "=== INFORMA√á√ïES IMPORTANTES - GUARDE ESTAS CREDENCIAIS ==="
echo ""

msg "$BRANCO" "üìÇ Diret√≥rio do projeto: $VERDE$PROJETO_DIR"
echo ""

msg "$AMARELO" "üîê CREDENCIAIS DE ACESSO:"
echo ""

msg "$BRANCO" "TRAEFIK DASHBOARD:"
msg "$BRANCO" "  üåê URL: $VERDE https://$URL_TRAEFIK"
msg "$BRANCO" "  üë§ Usu√°rio: $VERDE$USER_TRAEFIK"
msg "$BRANCO" "  üîë Senha: $VERMELHO$PASS_TRAEFIK"
echo ""

msg "$BRANCO" "PORTAINER:"
msg "$BRANCO" "  üåê URL: $VERDE https://$URL_PORTAINER"
msg "$BRANCO" "  üë§ Usu√°rio: $VERDE$USER_PORTAINER"
msg "$BRANCO" "  üîë Senha: $VERMELHO$PASS_PORTAINER"
echo ""

msg "$BRANCO" "MINIO:"
msg "$BRANCO" "  üåê Console: $VERDE https://$URL_MINIO"
msg "$BRANCO" "  üåê S3 API: $VERDE https://$URL_S3"
msg "$BRANCO" "  üë§ Usu√°rio: $VERDE$USER_MINIO"
msg "$BRANCO" "  üîë Senha: $VERMELHO$PASS_MINIO"
echo ""

msg "$BRANCO" "POSTGRESQL:"
msg "$BRANCO" "  üóÑÔ∏è Host: $VERDE localhost"
msg "$BRANCO" "  üîå Porta: $VERDE 5432"
msg "$BRANCO" "  üë§ Usu√°rio: $VERDE postgres"
msg "$BRANCO" "  üîë Senha: $VERMELHO$PASS_POSTGRES"
msg "$BRANCO" "  üìä Banco N8N: $VERDE n8n_queue"
echo ""

msg "$BRANCO" "RABBITMQ:"
msg "$BRANCO" "  üåê URL: $VERDE https://$URL_RABBITMQ"
msg "$BRANCO" "  üë§ Usu√°rio: $VERDE$USER_RABBITMQ"
msg "$BRANCO" "  üîë Senha: $VERMELHO$PASS_RABBITMQ"
msg "$BRANCO" "  üóÑÔ∏è Host: $VERDE rabbitmq"
msg "$BRANCO" "  üîå Porta AMQP: $VERDE 5672"
msg "$BRANCO" "  üîå Porta Management: $VERDE 15672"
echo ""

msg "$BRANCO" "N8N:"
msg "$BRANCO" "  ü§ñ Editor: $VERDE https://$N8N_HOST"
msg "$BRANCO" "  üîó Webhook: $VERDE https://$N8N_WEBHOOK_HOST"
msg "$BRANCO" "  üîê Chave de Criptografia: $VERMELHO$N8N_ENCRYPTION_KEY"
echo ""

msg "$BRANCO" "FAQ SYSTEM:"
msg "$BRANCO" "  üåê URL: $VERDE https://$URL_FAQ"
msg "$BRANCO" "  üóÑÔ∏è Banco: $VERDE chatdigi"
msg "$BRANCO" "  üë§ Usu√°rio BD: $VERDE$USER_FAQ"
msg "$BRANCO" "  üîë Senha BD: $VERMELHO$PASS_FAQ_USER"
msg "$BRANCO" "  üîó Webhook Sync: $VERDE https://$N8N_WEBHOOK_HOST/webhook/sync-rag"
echo ""

msg "$BRANCO" "CHATDIGI SYSTEM:"
msg "$BRANCO" "  üåê Frontend: $VERDE https://$URL_CHATDIGI_FRONTEND"
msg "$BRANCO" "  üîå Backend API: $VERDE https://$URL_CHATDIGI_BACKEND"
msg "$BRANCO" "  üóÑÔ∏è Banco: $VERDE chatdigi"
msg "$BRANCO" "  üë§ Usu√°rio BD: $VERDE$USER_FAQ"
msg "$BRANCO" "  üîë Senha BD: $VERMELHO$PASS_FAQ_USER"
msg "$BRANCO" "  üîê JWT Secret: $VERMELHO$PASS_CHATDIGI_JWT"
msg "$BRANCO" "  üîÑ JWT Refresh: $VERMELHO$PASS_CHATDIGI_REFRESH"
msg "$BRANCO" "  üî¥ Redis: $VERDE redis://redis:6379 (sem senha)"
echo ""

msg "$AMARELO" "üìÑ Credenciais salvas em:"
msg "$BRANCO" "  ‚Ä¢ $PROJETO_DIR/credenciais.txt"
echo ""
msg "$AMARELO" "üìÅ Estrutura de diret√≥rios:"
msg "$BRANCO" "  ‚Ä¢ $PROJETO_DIR/ - Diret√≥rio principal do cliente"
msg "$BRANCO" "  ‚Ä¢ $PROJETO_DIR/docker-compose.traefik-portainer.yml"
msg "$BRANCO" "  ‚Ä¢ $PROJETO_DIR/docker-compose.minio.yml"
msg "$BRANCO" "  ‚Ä¢ $PROJETO_DIR/docker-compose.redis.yml"
msg "$BRANCO" "  ‚Ä¢ $PROJETO_DIR/docker-compose.postgres.yml"
msg "$BRANCO" "  ‚Ä¢ $PROJETO_DIR/docker-compose.rabbitmq.yml"
msg "$BRANCO" "  ‚Ä¢ $PROJETO_DIR/docker-compose.n8n.yml"
msg "$BRANCO" "  ‚Ä¢ $PROJETO_DIR/docker-compose.faq.yml"
msg "$BRANCO" "  ‚Ä¢ $PROJETO_DIR/docker-compose.chatdigi.yml"
msg "$BRANCO" "  ‚Ä¢ $PROJETO_DIR/credenciais.txt"
msg "$BRANCO" "  ‚Ä¢ $PROJETO_DIR/letsencrypt/ - Certificados SSL"
echo ""

msg "$AMARELO" "=== ARQUIVOS CRIADOS ==="
msg "$BRANCO" "‚Ä¢ docker-compose.traefik-portainer.yml - Traefik + Portainer"
msg "$BRANCO" "‚Ä¢ docker-compose.minio.yml - MinIO"
msg "$BRANCO" "‚Ä¢ docker-compose.redis.yml - Redis"
msg "$BRANCO" "‚Ä¢ docker-compose.postgres.yml - PostgreSQL"
msg "$BRANCO" "‚Ä¢ docker-compose.rabbitmq.yml - RabbitMQ"
msg "$BRANCO" "‚Ä¢ docker-compose.n8n.yml - N8N (Editor, Webhook, Worker)"
msg "$BRANCO" "‚Ä¢ docker-compose.faq.yml - FAQ System"
msg "$BRANCO" "‚Ä¢ docker-compose.chatdigi.yml - ChatDigi System"
msg "$BRANCO" "‚Ä¢ credenciais.txt - Todas as credenciais"
echo ""
msg "$AMARELO" "=== CONFIGURA√á√ïES DE SISTEMA ==="
msg "$BRANCO" "‚Ä¢ Fuso hor√°rio: $(timedatectl show --property=Timezone --value)"
msg "$BRANCO" "‚Ä¢ Sincroniza√ß√£o NTP: $(timedatectl show --property=NTPSynchronized --value)"
msg "$BRANCO" "‚Ä¢ Hor√°rio atual: $(date)"
echo ""

msg "$AMARELO" "=== PR√ìXIMAS APLICA√á√ïES ==="
msg "$BRANCO" "Para adicionar novas aplica√ß√µes:"
msg "$BRANCO" "1. Crie um novo arquivo docker-compose.app.yml"
msg "$BRANCO" "2. Use o padr√£o de URL: app.$NOME_INSTANCIA.$DOMINIO_BASE"
msg "$BRANCO" "3. Conecte √† rede: ${NOME_INSTANCIA}_network"
msg "$BRANCO" "4. Execute: docker compose -f docker-compose.app.yml up -d"
echo ""

msg "$AMARELO" "=== COMANDOS √öTEIS ==="
msg "$BRANCO" "‚Ä¢ Ver status geral: cd $PROJETO_DIR && docker ps"
msg "$BRANCO" "‚Ä¢ Ver logs Traefik: cd $PROJETO_DIR && docker compose -f docker-compose.traefik-portainer.yml logs -f traefik"
msg "$BRANCO" "‚Ä¢ Ver logs Portainer: cd $PROJETO_DIR && docker compose -f docker-compose.traefik-portainer.yml logs -f portainer"
msg "$BRANCO" "‚Ä¢ Ver logs MinIO: cd $PROJETO_DIR && docker compose -f docker-compose.minio.yml logs -f"
msg "$BRANCO" "‚Ä¢ Ver logs Redis: cd $PROJETO_DIR && docker compose -f docker-compose.redis.yml logs -f"
msg "$BRANCO" "‚Ä¢ Ver logs PostgreSQL: cd $PROJETO_DIR && docker compose -f docker-compose.postgres.yml logs -f"
msg "$BRANCO" "‚Ä¢ Ver logs RabbitMQ: cd $PROJETO_DIR && docker compose -f docker-compose.rabbitmq.yml logs -f"
msg "$BRANCO" "‚Ä¢ Ver logs N8N: cd $PROJETO_DIR && docker compose -f docker-compose.n8n.yml logs -f"
msg "$BRANCO" "‚Ä¢ Ver logs FAQ: cd $PROJETO_DIR && docker compose -f docker-compose.faq.yml logs -f"
msg "$BRANCO" "‚Ä¢ Ver logs ChatDigi: cd $PROJETO_DIR && docker compose -f docker-compose.chatdigi.yml logs -f"
msg "$BRANCO" "‚Ä¢ Reiniciar Traefik: cd $PROJETO_DIR && docker compose -f docker-compose.traefik-portainer.yml restart traefik"
msg "$BRANCO" "‚Ä¢ Reiniciar Portainer: cd $PROJETO_DIR && docker compose -f docker-compose.traefik-portainer.yml restart portainer"
msg "$BRANCO" "‚Ä¢ Reiniciar MinIO: cd $PROJETO_DIR && docker compose -f docker-compose.minio.yml restart"
msg "$BRANCO" "‚Ä¢ Reiniciar Redis: cd $PROJETO_DIR && docker compose -f docker-compose.redis.yml restart"
msg "$BRANCO" "‚Ä¢ Reiniciar PostgreSQL: cd $PROJETO_DIR && docker compose -f docker-compose.postgres.yml restart"
msg "$BRANCO" "‚Ä¢ Reiniciar RabbitMQ: cd $PROJETO_DIR && docker compose -f docker-compose.rabbitmq.yml restart"
msg "$BRANCO" "‚Ä¢ Reiniciar N8N: cd $PROJETO_DIR && docker compose -f docker-compose.n8n.yml restart"
msg "$BRANCO" "‚Ä¢ Reiniciar FAQ: cd $PROJETO_DIR && docker compose -f docker-compose.faq.yml restart"
msg "$BRANCO" "‚Ä¢ Reiniciar ChatDigi: cd $PROJETO_DIR && docker compose -f docker-compose.chatdigi.yml restart"
echo ""

msg "$AMARELO" "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó"
msg "$AMARELO" "‚ïë        NEUROBOOST DIGITAL - Automa√ß√£o e IA                     ‚ïë"
msg "$AMARELO" "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù"

## Finaliza o log
log_message "=========================================="
log_message "INSTALA√á√ÉO CONCLU√çDA COM SUCESSO"
log_message "=========================================="
log_message "Vers√£o do script: $VERSION"
log_message "Nome da inst√¢ncia: $NOME_INSTANCIA"
log_message "Traefik: https://$URL_TRAEFIK"
log_message "Portainer: https://$URL_PORTAINER"
log_message "MinIO: https://$URL_MINIO"
log_message "S3: https://$URL_S3"
log_message "RabbitMQ: https://$URL_RABBITMQ"
log_message "N8N Editor: https://$N8N_HOST"
log_message "N8N Webhook: https://$N8N_WEBHOOK_HOST"
log_message "FAQ System: https://$URL_FAQ"
log_message "ChatDigi Frontend: https://$URL_CHATDIGI_FRONTEND"
log_message "ChatDigi Backend: https://$URL_CHATDIGI_BACKEND"
log_message "PostgreSQL: localhost:5432 (bancos: n8n_queue, chatdigi)"
log_message "Fuso hor√°rio configurado: $(timedatectl show --property=Timezone --value)"
log_message "Sincroniza√ß√£o NTP: $(timedatectl show --property=NTPSynchronized --value)"
log_message "Diret√≥rio do projeto: $PROJETO_DIR"
log_message "Credenciais salvas em: $PROJETO_DIR/credenciais.txt"
log_message "Log da instala√ß√£o: $LOG_FILE"
log_message "Data/Hora de conclus√£o: $(date)"
log_message "=========================================="

msg "$AMARELO" "üìù Log detalhado salvo em: $LOG_FILE"

## Arquivos docker-compose mantidos para consulta
msg "$BRANCO" "üìÅ Arquivos docker-compose mantidos para consulta futura:"
msg "$AMARELO" "‚Ä¢ docker-compose.traefik-portainer.yml - Traefik + Portainer"
msg "$AMARELO" "‚Ä¢ docker-compose.minio.yml - MinIO"
msg "$AMARELO" "‚Ä¢ docker-compose.redis.yml - Redis"
msg "$AMARELO" "‚Ä¢ docker-compose.postgres.yml - PostgreSQL"
msg "$AMARELO" "‚Ä¢ docker-compose.rabbitmq.yml - RabbitMQ"
msg "$AMARELO" "‚Ä¢ docker-compose.n8n.yml - N8N"
msg "$AMARELO" "‚Ä¢ docker-compose.faq.yml - FAQ System"
msg "$AMARELO" "‚Ä¢ docker-compose.chatdigi.yml - ChatDigi System"
msg "$VERDE" "‚úÖ Arquivos preservados para manuten√ß√£o"